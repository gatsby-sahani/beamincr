% beamincr.sty
% enhancements to beamer increment handling

\RequirePackage{etoolbox} % beamer uses this anyway
% abbreviate \expandafter
\let\x@=\expandafter

% choose the first line to get debugging messages on screen and log
\def\beamincrdebug#1{%
  \ifnum #1 > 0 
    \def\debug@message{\message}
  \else
    \def\debug@message{\@gobble}
  \fi
}
\beamincrdebug0

%% 
%% allow references to future labels
%%

% if true, (currently) undefined labels will resolve to 0 rather than raising an error
\newif\if@allowundefincrref
\def\framescanonlystate#1{\ifnum#1>0\relax\@denyscanonlyfalse\else\@denyscanonlytrue\fi}
\newcommand\allowundefinedincrrefs[1][1]{%
  \ifnum#1>0\relax\@allowundefincrreftrue\else\@allowundefincrreffalse\fi%
}



% change category of X to other, so it can be used to separate arguments without interference from
% Xs in the input.  this means we can't use X as a letter in this file.
\catcode`X=12


%% 
%% \resetincr[refspec] - (re)set the increment counter
%%

\newcounter{beamincr@lastreset}
\def\resetincr{%
  \@ifnextchar<%
    {\resetincr@angle}% called as action
    {\resetincr@normal}%
}

\newcommand\resetincr@normal[1][1]{%
  \@resetincr{\parseincrspec{#1}}%
}

% action form -- not for users
% beamer actions are documented to always call environments, but
% sometimes call commands instead.
\newenvironment<>{resetincrenv}{\resetincr#1}{}

\def\resetincr@angle<#1:#2>{% called as action
  \debug@message{action: setting increment to #2^^J}%
  \@resetincr{#2}% ignore the mode -- always "all"
}
\def\@resetincr#1{%
% etoolbox version -- allows inline calculation, but local by default
  \global\defcounter{beamerpauses}{#1+1}%
  \global\defcounter{beamincr@lastreset}{#1}%
}


%%
%% \fromincr<refspec> - set the increment counter and place following text on corresponding slide
%% 
  
\def\fromincr<#1>{%
  \resetincr[#1]%
  \onslide<.->\relax%
}

%% 
%% \incrlabel - increment labels
%%

% \incrlabel{foo} save the current "increment number" in the label 'foo' for
% reference with \incrref{foo} (and/or </foo/>).

% The "increment number" is defined by the use of \pause and relative overlay
% commands like \onslide<+->.  In general, it corresponds to the slide on which
% text that follows a <.> increment would appear.  For technical reasons this is
% one less than the value of the beamerpauses counter (unless that counter is
% 1).  This can cause confusion if \pause and <+> constructs are mixed.

% the internal label name includes the frame label if one is given -- this helps
% to keep the references valid across frames

%% current increment = max(1,\value{beamerpauses}-1) as a numeric value
\newcommand\@currentincr{%
  \ifnum 1 < \c@beamerpauses %
    \number\numexpr\c@beamerpauses - 1\relax%
  \else%
    \thebeamerpauses%
  \fi%
}

%% \incrlabel{label} - set label to current increment
%% \incrlabel<refspec>{label} - set label to increment evaluated from refspec

\newcommand\incrlabel{%
  \@ifnextchar<{\incrlabel@angle}{\incrlabel@normal}%
}
\newcommand\incrlabel@normal[1]{%
  \incrlabel@do{\beamer@againname}{#1}{\@currentincr}
}
\def\incrlabel@angle<#1>#2{%
  \incrlabel@do{\beamer@againname}{#2}{\parseincrspec{#1}}
}
\newcommand\incrlabel@do[3]{%
  \x@\x@\x@\xdef\x@\csname beamincr@#1@#2\endcsname{#3}%
}

%% \incrlabel@action is called using a |= action
% the action is placed at the beginning of the calling spec, which means it
% should be (almost) innermost, its argument containing only
% {\uncover<spec>{text of action}}.
% We need to read the label from inside the text.

% #1: spec
% #2: arg = {\uncover<spec>{text}}
\def\incrlabel@action<#1>#2{%
  \x@\@incrlabel@action@parse\@incrlabel@action@unbracearg#2//X<#1>X%
}
% expose contents of grouped text arg
\def\@incrlabel@action@unbracearg#1<#2>#3{%
  #1<#2>#3% removes {} from #3
}

% #1: \uncover
% #2: uncover spec
% #3: text before label
% #4: label
% #5: text after label
% #6: mode spec to = action (always 'all')
% #7: numeric spec to = action
\def\@incrlabel@action@parse#1<#2>#3/#4/#5X<#6:#7>X{%
  \@ifempty{#4}%
    {}%#1<#2>{#3 \@dropslashslashxx#5XX}}% ignore silently if label missing
    {\debug@message{action: setting label /#4/=\@currentincr+#7^^J}%
      \ifx*#7%
        \incrlabel{#4}%
      \else
        \incrlabel</.(#7)/>{#4}%
      \fi
    }%
  \@ifempty{#5}%
    {#1<#2>{#3}}% no /s in input: terminal //s removed
    {#1<#2>{#3\@dropslashslashxx#5XX}}% /{}/ in input, copy remaining arg and drop terminator
}
\def\@dropslashslashxx#1//XX{#1}

% the environment form will be called
% as \begin{incrlabel@actionenv}<spec>\begin{uncoverenv}<spec>text\end...
% \collect@body seems not to work this deep inside beamer environments.  So in
% this case, we just read to the first /.../.  If there isn't one this will
% generate a (somewhat interpretable) error.
\newenvironment<>{incrlabel@actionenv}{\@incrlabel@action@futureget#1}{}

\def\@incrlabel@action@futureget<#1:#2>#3/#4/{%
  \@ifempty{#4}%
    {#3}% ignore silently if label missing
    {\debug@message{actionenv: <#1:#2> setting label /#4/=\@currentincr+#2^^J}%
      \ifx*#2%
        \incrlabel{#4}%
      \else
        \incrlabel</.(#2)/>{#4}%
      \fi
      #3%
    }%
}




%% \incrref{label} - print the incr number associated with label in the current frame
%% \incrref[framename]{label} - reference a different frame
%% \incrref{label(offset)} - add a numerical offset, possibly negative.

% The tricky part is the optional offset.  The idea is to use a helper function
% to call the main parser (\def'd to expect parens) with trailing ().  If there
% were parens in the label, the parser will see them first, and use
% \@gobbleparens to throw away the trailing ones (and any text between the real
% ones and the trailers).  If not, the parser sees an empty arg between the
% parens and knows to ignore it.


\newcommand\incrref[2][\beamer@againname]{%
  \@incrref[#1]#2()%
}
\def\@incrref[#1]#2(#3){%
  \@ifempty{#3}%
           {\@@incrref[#1]#2(0)}%
           {\@@incrref[#1]#2(#3)\@gobbleparens}%
}

% avoid expansion of ! refs until the bitter end using \protected\def
\protected\def\beamincr@lastreset#1{%
  % At one point in its internals beamer \futurelets \next=\beamincr@lastresest, and calls
  % \ifcat\next a, which evaluates \beamincr@lastresest{a}, which fails as `a is not a number.  Test
  % specifically for this case.
  \if a#1 0a\else
    \ifnum\c@beamincr@lastreset=0 % ignore offset if reset to 0
      0%
    \else
      \the\numexpr #1+\c@beamincr@lastreset\relax%
    \fi
  \fi
}
\def\@@incrref[#1]#2(#3){%
  \if.#2% this breaks if the incrlabel is .foo.  fixes all seem to require additional packages
    \@@incrref@offset{\@currentincr}{#3}%
  % \number \numexpr \@currentincr + #3\relax%
  \else\if!#2%
   \beamincr@lastreset{#3}%
  \else
    \@ifundefined{beamincr@#1@#2}%
      {\if@allowundefincrref\x@\@firstoftwo\else\x@\@secondoftwo\fi
          {\@@incrref@offset{0}{0}}%
          {\PackageError{beamincr}{No label #2 in frame #1}{}}%
      }%}%
      {\x@\@@incrref@offset\x@{\csname beamincr@#1@#2\endcsname}{#3}}%
  \fi\fi%
}
\def\@gobbleparens#1(){}

% no offset on 0 increments
\def\@@incrref@offset#1#2{\ifnum#1=0 \x@\@firstoftwo\else\x@\@secondoftwo\fi{0}{\number\numexpr #1+#2\relax}}

  

%% \parseincrspec - parse /incrlabel/ refs
% \parseincrspec{spec} replaces incr labels within // chars with the
% corresponding values returned by \incrref.

% Again, we use a helper function that adds empty // chars to terminate the
% parser.  In this case we keep going until we hit the terminal //.

% start the parsing
\def\parseincrspec#1{%
  \@parseincrspec#1//%
}

% split input by /
% #1: input to first /
% #2: input to next /
\def\@parseincrspec#1/#2/{%
  #1% copy input to first /
  \@ifempty{#2}{}{% if empty we're done
    \@parseincrspec@handledash@protectoffset#2()X%
    \@parseincrspec% keep going
    % \@incrref[\beamer@againname]#2()% else resolve this ref
    % \@parseincrspec% keep going
  }%
}


\def\@zeroorempty#1{\ifnum0=0#1 \x@\@firstoftwo\else\x@\@secondoftwo\fi{0}{}}

% need to parse any offet, in case its negative (and so has a '-')
\def\@parseincrspec@handledash@protectoffset#1(#2)#3X{%
  \@ifempty{#2}{%
    \@parseincrspec@handledash()X#1-X-%
  }{%
    \x@\@parseincrspec@handledash\@xcopytoparens{(#2)()X#1}#3-X-%
  }%
}
% de{}s first arg
\def\@xcopytoparens#1#2(){#1#2}

% foo -> Xfoo-X-  -> #2=foo #3=X
% -foo -> X-foo-X- ->#2={} #3=foo remaining X-
% foo- -> Xfoo--X- ->#2=foo #3={} remaining X-
\def\@parseincrspec@handledash#1X#2-#3-{%
  \@ifempty{#2}{% leading -, label in #3, gobble X-
    \@zeroorempty{\@incrref[\beamer@againname]#3#1}-\@incrref[\beamer@againname]#3#1%
    \@gobblexdash%
  }{%
    \@ifempty{#3}{% trailing -, label in #3, gobble X-
      \@incrref[\beamer@againname]#2#1-\@zeroorempty{\@incrref[\beamer@againname]#2#1}%
      \@gobblexdash%
    }{% no -, label in #2
      \@incrref[\beamer@againname]#2#1}% just resolve this ref
    }%
}
\def\@gobblexdash#1X-{}





%% \parseresetspec - parse !(incr) actions
\def\parseresetspec#1{%
  \@parseresetspec{}#1!X!XX% init: empty actions; input terminated by !X!XX
}

% split input by !
% #1: accumulated actions
% #2:input to first !
% #3:input to next !
\def\@parseresetspec#1#2!#3!{%
  #2%copy input to first !
  \ifX#3\x@\@firstoftwo\else\x@\@secondoftwo\fi
      {#1\x@\@gobbletoxx}%just print accumulated actions and remove the XX
      {\@parseresetspec@grabnum{#1}{}#3!}%else found !: grab the number at start of #3
}
\def\@gobbletoxx#1XX{}

% hack to test for digit
\def\ifisdigit#1{\ifcat_\ifnum9<1#1 _\else A\fi\x@\@firstoftwo\else\x@\@secondoftwo\fi}

% found a ! -- read the following number
% #1: accumulated actions
% #2: number so far
% #3: next token
% #4: remaining input to !
\def\@parseresetspec@grabnum#1#2#3#4!{% #1->accum actions #2->number so far #3->next token 
  \ifisdigit#3%
    {\@ifempty{#4}% no more input
       {\@@parseresetspec{#1}{#2#3}!}% number is #2#3
       {\@parseresetspec@grabnum{#1}{#2#3}#4!}}% check for more digits
    {\@ifempty{#2}%
       {\@parseresetspec{#1}#3#4!}% no number, just kill !
       {\@@parseresetspec{#1}{#2}#3#4!}}% number is #2
}

% got the number: create action and recurse
% #1: accumulated actions
% #2: increment number
% #3: rest of input to next !
\def\@@parseresetspec#1#2#3!{%
  #2%put count value on stream
  \@parseresetspec{#1|resetincr\string @#2}#3!%add new action and parse remainder
}


%% \parselabelspec - parse |= actions

% parse | segements
\def\parselabelspec#1{%
  \@parselabelspec@field#1|XX.\end%
}
% #1: first token of field
% #2: rest of field
% #3: rest of spec
% #4: accumulated fields
% #5: label action fields
\def\@parselabelspec@field#1#2|#3X#4X#5#6\end{%
  \ifx=#1% field starts with =
    \ifx=#5 % already have a label
      \PackageError{beamincr}{Only one label action allowed in spec}{}%
    \else
      \@ifempty{#3}% last field
        {\@parselabelspec@field@label=#2()\end#4}%
        {\@parselabelspec@field#3X#4X=#2\end}%
    \fi
  \else% not a label field
    \@ifempty{#3}% last field
      {\@parselabelspec@field@label#5#6()\end#4\string|#1#2}%
      {\@parselabelspec@field#3X#4\string|#1#2X#5#6\end}%
   \fi
}

\def\@parselabelspec@field@label#1#2(#3)#4\end{%
  \if=#1% label found
    \@ifempty{#2}% check there's nothing between = and offset
      {\@ifempty{#3}% 
        {incrlabel@action\string @*}% no offset
        {incrlabel@action\string @#3}% place offset as number
    }{%
      \PackageError{beamincr}{Label action field contains extra text: #2}{}%
    }%
  \else% no label -- gobble the following | character
    \x@\@gobblepipe%
  \fi
}
\def\@gobblepipe#1|{}


%% \parsedefincspec - parse default spec inclusion

% parse | segements
\def\parsedefincspec#1{%
  \@parsedefincspec@field#1|X%
}
% #1: first token of field
% #2: rest of field
% #3: rest of spec
\def\de@ngle<#1>{#1}
\def\@parsedefincspec@field#1#2|#3X{%
  \ifx ~#1\x@\@firstoftwo\else\x@\@secondoftwo\fi% if field starts with @
    {\x@\de@ngle\beamer@defaultospec}%insert default spec
    {#1#2}%copy field
  \@ifempty{#3}% last field
    {}%
    {|\@parsedefincspec@field#3X}%
}

%% 
%% install overlay parsing in beamer commands
%%

% this involves some minor hackery: the idea is to redefine the macro
% \beamer@masterdecode (which seems to be the top level call to parse overlay
% specs) to first parse the incr refs and then call beamer's original parser.

% save the original beamer overlay processor
\let\beamer@masterdecode@orig=\beamer@masterdecode
% now replace it, calling the old one
\def\beamer@masterdecode#1{%
  \edef\parsed@spec{\parsedefincspec{#1}}%
  \edef\parsed@spec{\x@\parseincrspec\x@{\parsed@spec}}%
  \edef\parsed@spec{\x@\parseresetspec\x@{\parsed@spec}}%
  \edef\parsed@spec{\x@\parselabelspec\x@{\parsed@spec}}%
  \debug@message{masterdecode: <#1> -> <\parsed@spec>^^J}%
  \x@\beamer@masterdecode@orig\x@{\parsed@spec}%
}%

% \againframe seems to need special treatment
\let\beamer@againframe@orig=\beamer@againframe
\def\beamer@againframe<#1>{\beamer@againframe@orig<\parseincrspec{#1}>}

%% 
%% \againframe variants
%%

%% Access the *contents* of a previously defined frame.  Allows more fine-grained access, changes etc.
\newcommand{\againframebody}[1]{%
  \@ifundefined{beamer@again@#1}%
  {\ClassError{beamer}{No frame has been designated to resume under
      the name "#1"}{}}%
  \x@\csname beamer@again@#1\endcsname%
}

%% Run a frame again, with new title.  Original definition MUST use \frametitle (not an arg to \begin{frame})
% \begin{frame}[label=foo]\frametitle{first title}\end{frame}
% \againframeretitle{foo}{second title}
% The new title will overwrite the stored one, and appear in subsequent calls to
% \againframe

\def\againframeretitle{\@ifnextchar<{\beamer@againframeretitle}{\beamer@againframeretitle<*>}}
\def\beamer@againframeretitle<#1>{\@ifnextchar[{\beamer@@againframeretitle<#1>}{\beamer@@againframeretitle<#1>[]}}
\def\beamer@@againframeretitle<#1>[{\@ifnextchar<{\beamer@@@@againframeretitle<#1>[}{\beamer@@@againframeretitle<#1>[<*>][}}
\def\beamer@@@@againframeretitle<#1>[#2]{\@ifnextchar[{\beamer@@@againframeretitle<#1>[{#2}]}{\beamer@@@againframeretitle<#1>[{#2}][]}}
\def\beamer@@@againframeretitle<#1>[#2][#3]#4#5{%
  \@ifundefined{beamer@again@#4}%
  {\ClassError{beamer}{No frame has been designated to resume under
      the name "#4"}{}}%
  {%
  \def\beamer@temp{\begin{frame}<\parseincrspec{#1}>[#2][{#3},relabel=#4]{}{}}%
  \x@\let\x@\beamer@templet\csname beamer@again@#4\endcsname%
  \x@\beamer@temp\beamer@templet\frametitle{#5}\end{frame}}%
}


%% 
%% \handoutframe - show specific overlay stage(s) in handout.
%%

% The handout and trans modes usually "flatten" all the overlays of a
% frame.  This may not be desirable, for example when text has been
% replaced, rather than augmented.  \handoutframe is a wrapper
% to \againframe that only runs in handout mode, and temporarily
% switches to presentation mode to allow specific frames to be
% rendered as they would be onscreen.  With optional argument, does
% the same for other modes (e.g. trans).

% Example:
% \begin{frame}<handout:0>[label=complexframe]complex stuff\end{frame}
% \handoutframe<2,5-6>{complexframe}

% Idea from:
% https://tex.stackexchange.com/questions/455444/beamer-overlays-and-handout-exclude-frames-from-handout/455459#455459
% but a different interface.

% as we need to reset the mode (or end a group) after the \againframe call we
% need to parse and pass to \againframe all potential arguments.  So we follow
% the \againframe definition from beamer.
\newcommand\handoutframe[1][handout]{% check for <spec>
  \@ifnextchar<{\handoutframe@[#1]}{\handoutframe@[#1]<*>}%
}
\def\handoutframe@[#1]<#2>{% check for [opt]
  \@ifnextchar[{\handoutframe@@[#1]<#2>}{\handoutframe@@[#1]<#2>[]}%
}
\def\handoutframe@@[#1]<#2>[{%check if opt is [<def>]
  \@ifnextchar<{\handoutframe@@@[#1]<#2>[}{\handoutframe@do[#1]<#2>[<*>][}%
}
\def\handoutframe@@@[#1]<#2>[#3]{%read [<def>] and check for [opt]
  \@ifnextchar[{\handoutframe@do[#1]<#2>[{#3}]}{\handoutframe@do[#1]<#2>[{#3}][]}%
}
\def\handoutframe@do[#1]<#2>[#3][#4]#5{%
  \mode<#1>{%
%    grouping seems to be enough, but also possible to explicitly save
%    and restore current mode if necessary.
%    \edef\save@currentmode{\beamer@currentmode}
    \begingroup
    \def\beamer@currentmode{beamer}%
    % we've parsed all the arguments, so just call the inner function
    \beamer@@@againframe<\parseincrspec{#2}>[{#3}][#4]{#5}%
    \endgroup
%    \edef\beamer@currentmode{\save@currentmode}%
  }%
}


%% 
%% \framescanonly 
%% 
% This command is similar to a <0> argument to \begin{frame} in that it
% suppresses the frame output.  But the frame is still scanned and so increment
% labels are available for use with \againframe or \handoutframe.

% Protect \mode from expansion as frame scans input.   If expanded then the
% effective mode would be frozen at first expansion, fouling \handoutframe's
% mode switch
\protected\def\beamincr@protected@mode{\mode}

\newcommand<>\framescanonly{%
  \if@denyscanonly\else%
  \beamincr@protected@mode#1{%
    \@ifundefined{AddToHookNext}%
      {\PackageWarning{beamincr}{\framescanonly is not supported in this LaTe\stringX version}}%
      {\AddToHookNext{shipout/before}{\DiscardShipoutBox}}%
  }%
  \fi
}

\newif\if@denyscanonly
\def\framescanonlystate#1{\ifnum#1>0 \@denyscanonlyfalse\else\@denyscanonlytrue\fi}


%% 
%% a rudimentary increment-aware align environment
%%

%% user-facing commands
\newenvironment{incralign}{\collect@body\@incralign@nostar}{\ignorespacesafterend}
\newenvironment{incralign@star}{\collect@body\@incralign@star}{\ignorespacesafterend}

% make * version accessible
\cslet{incralign*}\incralign@star
\cslet{endincralign*}\endincralign@star

% remember the old ones
\let\amsalign=\align%
\let\endamsalign=\endalign
\letcs\amsalign@star{align*}
% note: \end{align*} just calls \endalign: we need to ensure this is
% the ams version even after \makealignincremental
\let\endamsalign@star=\endamsalign
\cslet{amsalign*}\amsalign@star
\cslet{endamsalign*}\endamsalign@star

\def\makealignincremental{%
  \gdef\align{\incralign}%
  \gdef\endalign{\endincralign}%
  \csgdef{align*}{\incralign@star}%
  \csgdef{endalign*}{\endincralign@star}%
}
\def\makealignams{%
  \gdef\align{\amsalign}%
  \gdef\endalign{\endamsalign}%
  \csgdef{align*}{\amsalign@star}%
}


% default increment spec               
\newcommand\incraligndefaultspec[1][<+->&<.->&<.->&<.->&<.->&<.->&<.->&<.->]{%
  \gdef\@incralign@defaultspec{#1}%
}
\incraligndefaultspec


%% the rest are internals

% token register to collect the processed toks               
\newtoks\@incraligntoks

% process body of environment
\def\@incralign@nostar#1{\@incralign[amsalign]{#1}}
\def\@incralign@star#1{\@incralign[amsalign@star]{#1}}
\def\@incralign[#1]#2{%
  \@incraligntoks={}% clear processed token list
  \debug@message{send to process@line: \unexpanded{#2}\\X^^J}%
  \@incralign@opt#2\\X% process raw body token by token (\\ added to last line wiill be removed)
  \debug@message{send to #1: \the\@incraligntoks^^J}%
  \begin{#1}% pass tokens to align
    \the\@incraligntoks
  \end{#1}%
}

% use the default spec if optional arg absent
\def\@incralign@opt{%
  \@ifnextchar[%
    {\@incralign@process@line}%
    {\x@\@incralign@process@line\x@[\@incralign@defaultspec]}%
}
  
% process next line
% #1: increment spec
% #2: this line
% #3: remaining lines  
\def\@incralign@process@line[#1]#2\\#3X{%
%  \debug@message{process@line: spec #1| line: #2 | remaining body: #3^^J}%
  \@ifempty{#2}{}% empty environment?
  {% insert & at the end of the line
     \@incralign@process@field[#1]#1&X#2&\\#3X%
  }%
}

% process next field
% #1: full spec
% #2: spec to next &
% #3: remaining spec
% #4: remaning body
\def\@incralign@process@field[#1]#2&#3X#4X{%
%  \debug@message{process@field:  spec: #2 | remaining spec: #3 | remaining body: #4^^J}%
  \@incralign@field@optspec[#1][#2][#3]#4X%
}

% check for overlay spec within the field
% #1: full spec
% #2: spec for this field
% #3: remaining spec
\def\@incralign@field@optspec[#1][#2][#3]{%
%  \debug@message{incraligntoamp@opt: spec: #3 | remain spec: #4^^J}%
  \@ifnextchar<%input starts with overlay spec char
    {\@incraligntoamp[#1][#3][#2]}%
    {\@incraligntoamp[#1][#3][#2]#2}%
}

% process field teminated by &
% #1: full spec
% #2: remaining spec
% #3: default spec for this field
% #4: spec for this field
% #5: field contents
% #6: remaining line
% #7: remaining body
\def\@incraligntoamp[#1][#2][#3]<#4>#5&#6\\#7X{%
  \@incraligntoks=\x@{\the\@incraligntoks \def\beamer@defaultospec{#3}\action<#4>{#5}}%
  \@ifempty{#6}%
     {% reached last field on line
        \@ifempty{#7}{}% no more lines - we're done
          {% else
            \@incraligntoks=\x@{\the\@incraligntoks \\}%
            \@incralignbreak@checkopt#7X#1X% check for optional arg after \\
          }%
     }%
     {% else more fields
        \@incraligntoks=\x@{\the\@incraligntoks &}%
        \@ifempty{#2}% reuse fullspec if we've exhausted the current one
        {\@incralign@process@field[#1]#1&X#6\\#7X}%
        {\@incralign@process@field[#1]#2X#6\\#7X}%
     }%
}

% check for optional arg after break
\def\@incralignbreak@checkopt{%
  \@ifnextchar[%
    {\@incralignbreak@getopt}%
    {\@incralignbreak@noopt}%
}

% no optional arg after break: just process
% #1: rest of body
% #2: full spec
\def\@incralignbreak@noopt#1X#2X{%
  \@incralign@process@line[#2]#1X%
}

% read optional arg after break
% #1: opt arg
% #2: rest of body
% #3: full spec
\def\@incralignbreak@getopt[#1]#2X#3X{%
  \@incraligntoks=\x@{\the\@incraligntoks [#1]}%
  \@incralign@process@line[#3]#2X%
}
      
    

\catcode`X=11

               
               
