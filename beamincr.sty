% beamincr.sty
% enhancements to beamer increment handling

\RequirePackage{etoolbox} % beamer uses this anyway
\RequirePackage{environ} % for long Collect@Body

% change category of X to other, so it can be used to separate arguments without interference from
% Xs in the input.  this means we can't use X as a letter in this file.
\catcode`X=12

% abbreviate \expandafter
\let\x@=\expandafter

% if #1 is empty or whitespace (incl \par) -> #2 else -> #3
\long\def\ifwhitespace#1#2#3{\@ifwhitespace#1\parX{#2}{#3}}
\long\def\@ifwhitespace#1\par#2X#3#4{%
  \@ifempty{#1}{\@ifempty{#2}{#3}{\@ifwhitespace#2X{#3}{#4}}}{#4}%
}

% compare #1 to first token of #2, if equal -> #3 else ->#4
\long\def\iffirst#1#2#3#4{\@ifempty{#2}{#4}{\@iffirst#1#2X{#3}{#4}}}
\long\def\@iffirst#1#2#3X#4#5{\if#1#2\x@\@firstoftwo\else\x@\@secondoftwo\fi{#4}{#5}}


% choose the first line to get debugging messages on screen and log
\def\beamincrdebug#1{%
  \ifnumgreater{#1}{0}%
    {\gdef\debug@message{\message}}
    {\gdef\debug@message{\@gobble}}
}
\beamincrdebug0

%% 
%% allow references to future labels
%%

% if true, (currently) undefined labels will resolve to 0 rather than raising an error
\newif\if@allowundefincrref
\newcommand\allowundefinedincrrefs[1][1]{%
  \ifnumgreater{#1}{0}{\@allowundefincrreftrue}{\@allowundefincrreffalse}%
}





%% 
%% \resetincr[refspec] - (re)set the increment counter
%%

\newcounter{beamincr@lastreset}
\def\resetincr{%
  \@ifnextchar<%
    {\resetincr@angle}% called as action
    {\resetincr@normal}%
}

\newcommand\resetincr@normal[1][1]{%
  \@resetincr{\parseincrspec{#1}}%
}

% action form -- not for users
% beamer actions are documented to always call environments, but
% sometimes call commands instead.
\newenvironment<>{resetincrenv}{\resetincr#1}{}

\def\resetincr@angle<#1:#2>{% called as action
  \debug@message{action: setting increment to #2^^J}%
  \@resetincr{#2}% ignore the mode -- always "all"
}
\def\@resetincr#1{%
% etoolbox defcounter allows inline calculation, but local by default
  \ifnumgreater{#1}{0}%
    {\global\defcounter{beamerpauses}{#1+1}}%
    {\global\defcounter{beamerpauses}{#1}}%
  \global\defcounter{beamincr@lastreset}{#1}%
}


%%
%% \fromincr<refspec> - set the increment counter and place following text on corresponding slide
%% 
  
\def\fromincr<#1>{%
  \resetincr[#1]%
  \onslide<.->\relax%
}

%% 
%% \incrlabel - increment labels
%%

% \incrlabel{foo} save the current "increment number" in the label 'foo' for
% reference with \incrref{foo} (and/or </foo/>).

% The "increment number" is defined by the use of \pause and relative overlay
% commands like \onslide<+->.  In general, it corresponds to the slide on which
% text that follows a <.> increment would appear.  For technical reasons this is
% one less than the value of the beamerpauses counter (unless that counter is
% 1).  This can cause confusion if \pause and <+> constructs are mixed.

% the internal label name includes the frame label if one is given -- this helps
% to keep the references valid across frames

%% current increment = max(1,\value{beamerpauses}-1) as a numeric value
\newcommand\@currentincr{%
  \ifnumless{1}{\c@beamerpauses}%
    {\number\numexpr\c@beamerpauses - 1\relax}%
    {\thebeamerpauses}%
}

%% user accessible version -- smells like a counter
\newcommand\theincrement{\@currentincr}

%% \incrlabel{label} - set label to current increment
%% \incrlabel<refspec>{label} - set label to increment evaluated from refspec

\newcommand\incrlabel{%
  \@ifnextchar<{\incrlabel@angle}{\incrlabel@normal}%
}
\newcommand\incrlabel@normal[1]{%
  \incrlabel@do{\beamer@againname}{#1}{\@currentincr}%
}
\def\incrlabel@angle<#1>#2{%
  \incrlabel@do{\beamer@againname}{#2}{\parseincrspec{#1}}%
}
\newcommand\incrlabel@do[3]{%
  \x@\x@\x@\xdef\x@\csname beamincr@#1@#2\endcsname{#3}%
}

%% \incrlabel@action is called using a |= action
% the action is placed at the beginning of the calling spec, which means it
% should be (almost) innermost, its argument containing only
% {\uncover<spec>{text of action}}.
% We need to read the label from inside the text.

% #1: spec
% #2: arg = {\uncover<spec>{text}}
\long\def\incrlabel@action<#1>#2{%
  \x@\@incrlabel@action@parse\@incrlabel@action@unbracearg#2//X<#1>X%
}
% expose contents of grouped text arg
\long\def\@incrlabel@action@unbracearg#1<#2>#3{%
  #1<#2>#3% removes {} from #3
}

% #1: \uncover
% #2: uncover spec
% #3: text before label
% #4: label
% #5: text after label
% #6: mode spec to = action (always 'all')
% #7: numeric spec to = action
\long\def\@incrlabel@action@parse#1<#2>#3/#4/#5X<#6:#7>X{%
  \@ifempty{#4}%
    {}%#1<#2>{#3 \@dropslashslashxx#5XX}}% ignore silently if label missing
    {\debug@message{action: setting label /#4/=\@currentincr+#7^^J}%
      \ifx*#7%
        \incrlabel{#4}%
      \else%
        \incrlabel</.(#7)/>{#4}%
      \fi%
    }%
    \@ifempty{#5}%
      {\def\remain{}}%  no /s in input: terminal //s removed
      {\long\edef\remain{\expandonce{\@dropslashslashxx#5XX}}}% /{}/ in input, copy remaining arg and drop terminator
    \long\def\put##1{#1<#2>{#3##1}}%
    \x@\put\x@{\remain}%
}
\long\def\@dropslashslashxx#1//XX{#1}

% the environment form will be called
% as \begin{incrlabel@actionenv}<spec>\begin{uncoverenv}<spec>text\end...
% \collect@body seems not to work this deep inside beamer environments.  So in
% this case, we just read to the first /.../.  If there isn't one this will
% generate a (somewhat interpretable) error.
\newenvironment<>{incrlabel@actionenv}{\@incrlabel@action@futureget#1}{}

\def\@incrlabel@action@futureget<#1:#2>#3/#4/{%
  \@ifempty{#4}%
    {#3}% ignore silently if label missing
    {\debug@message{actionenv: <#1:#2> setting label /#4/=\@currentincr+#2^^J}%
      \ifx*#2%
        \incrlabel{#4}%
      \else
        \incrlabel</.(#2)/>{#4}%
      \fi
      #3%
    }%
}




%% \incrref{label} - print the incr number associated with label in the current frame
%% \incrref[framename]{label} - reference a different frame
%% \incrref{label(offset)} - add a numerical offset, possibly negative.

% The tricky part is the optional offset.  The idea is to use a helper function
% to call the main parser (\def'd to expect parens) with trailing ().  If there
% were parens in the label, the parser will see them first, and use
% \@gobbleparens to throw away the trailing ones (and any text between the real
% ones and the trailers).  If not, the parser sees an empty arg between the
% parens and knows to ignore it.


\newcommand\incrref[2][\beamer@againname]{%
  \@incrref[#1]#2()%
}
\def\@incrref[#1]#2(#3){%
  \@ifempty{#3}%
           {\@@incrref[#1]#2(0)}%
           {\@@incrref[#1]#2(#3)\@gobbleparens}%
}

% avoid expansion of ! refs until the bitter end using \protected\def
\protected\def\beamincr@lastreset#1{%
  % At one point in its internals beamer \futurelets \next=\beamincr@lastresest, and calls
  % \ifcat\next a, which evaluates \beamincr@lastresest{a}, which fails as `a is not a number.  Test
  % specifically for this case.
  \if a#1 0a\else
    \ifnumequal{\c@beamincr@lastreset}{0}% ignore offset if reset to 0
      {0}{\the\numexpr #1+\c@beamincr@lastreset\relax}%
  \fi
}
\def\@@incrref[#1]#2(#3){%
  \if.#2% this breaks if the incrlabel is .foo.  fixes all seem to require additional packages
    \@@incrref@offset{\@currentincr}{#3}%
  % \number \numexpr \@currentincr + #3\relax%
  \else\if!#2%
   \beamincr@lastreset{#3}%
  \else
    \@ifundefined{beamincr@#1@#2}%
      {\if@allowundefincrref\x@\@firstoftwo\else\x@\@secondoftwo\fi
          {\@@incrref@offset{0}{0}}%
          {\PackageError{beamincr}{No label #2 in frame #1}{}}%
      }%}%
      {\x@\@@incrref@offset\x@{\csname beamincr@#1@#2\endcsname}{#3}}%
  \fi\fi%
}
\def\@gobbleparens#1(){}

% no offset on 0 increments
\def\@@incrref@offset#1#2{\ifnumequal{#1}{0}{0}{\number\numexpr #1+#2\relax}}

  

%% \parseincrspec - parse /incrlabel/ refs
% \parseincrspec{spec} replaces incr labels within // chars with the
% corresponding values returned by \incrref.

% Again, we use a helper function that adds empty // chars to terminate the
% parser.  In this case we keep going until we hit the terminal //.

% start the parsing
\def\parseincrspec#1{%
  \@parseincrspec#1//%
}

% split input by /
% #1: input to first /
% #2: input to next /
\def\@parseincrspec#1/#2/{%
  #1% copy input to first /
  \@ifempty{#2}{}{% if empty we're done
    \@parseincrspec@handledash@protectoffset#2()X%
    \@parseincrspec% keep going
  }%
}


\def\@zer@orempty#1{\ifnum0=0#1 \x@\@firstoftwo\else\x@\@secondoftwo\fi{0}{}}

% need to parse any offet, in case it's negative (and so has a '-')
\def\@parseincrspec@handledash@protectoffset#1(#2)#3X{%
  \@ifempty{#2}{%
    \@parseincrspec@handledash()X#1-X-%
  }{%
    \x@\@parseincrspec@handledash\@xcopytoparens{(#2)()X#1}#3-X-%
  }%
}
% de{}s first arg
\def\@xcopytoparens#1#2(){#1#2}

% foo -> Xfoo-X-  -> #2=foo #3=X
% -foo -> X-foo-X- ->#2={} #3=foo remaining X-
% foo- -> Xfoo--X- ->#2=foo #3={} remaining X-
\def\@parseincrspec@handledash#1X#2-#3-{%
  \@ifempty{#2}{% leading -, label in #3, gobble X-
    \@zer@orempty{\@incrref[\beamer@againname]#3#1}-\@incrref[\beamer@againname]#3#1%
    \@gobblexdash%
  }{%
    \@ifempty{#3}{% trailing -, label in #3, gobble X-
      \@incrref[\beamer@againname]#2#1-\@zer@orempty{\@incrref[\beamer@againname]#2#1}%
      \@gobblexdash%
    }{% no -, label in #2
      \@incrref[\beamer@againname]#2#1}% just resolve this ref
    }%
}
\def\@gobblexdash#1X-{}





%% \parseresetspec - parse !(incr) actions
\def\parseresetspec#1{%
  \@parseresetspec{}#1!X!XX% init: empty actions; input terminated by !X!XX
}

% split input by !
% #1: accumulated actions
% #2:input to first !
% #3:input to next !
\def\@parseresetspec#1#2!#3!{%
  #2%copy input to first !
  \ifX#3\x@\@firstoftwo\else\x@\@secondoftwo\fi
      {#1\x@\@gobbletoxx}%just print accumulated actions and remove the XX
      {\@parseresetspec@grabnum{#1}{}#3!}%else found !: grab the number at start of #3
}
\def\@gobbletoxx#1XX{}

% hack to test for digit
\def\ifisdigit#1{\ifcat_\ifnum9<1#1 _\else A\fi\x@\@firstoftwo\else\x@\@secondoftwo\fi}

% found a ! -- read the following number
% #1: accumulated actions
% #2: number so far
% #3: next token
% #4: remaining input to !
\def\@parseresetspec@grabnum#1#2#3#4!{% #1->accum actions #2->number so far #3->next token 
  \ifisdigit#3%
    {\@ifempty{#4}% no more input
       {\@@parseresetspec{#1}{#2#3}!}% number is #2#3
       {\@parseresetspec@grabnum{#1}{#2#3}#4!}}% check for more digits
    {\@ifempty{#2}%
       {\@parseresetspec{#1}#3#4!}% no number, just kill !
       {\@@parseresetspec{#1}{#2}#3#4!}}% number is #2
}

% got the number: create action and recurse
% #1: accumulated actions
% #2: increment number
% #3: rest of input to next !
\def\@@parseresetspec#1#2#3!{%
  #2%put count value on stream
  \@parseresetspec{#1|resetincr\string @#2}#3!%add new action and parse remainder
}


%% \parselabelspec - parse |= actions

% parse | segements
\def\parselabelspec#1{%
  \@parselabelspec@field#1|XX.\end%
}
% #1: first token of field
% #2: rest of field
% #3: rest of spec
% #4: accumulated fields
% #5: label action fields
\def\@parselabelspec@field#1#2|#3X#4X#5#6\end{%
  \ifx=#1% field starts with =
    \ifx=#5 % already have a label
      \PackageError{beamincr}{Only one label action allowed in spec}{}%
    \else
      \@ifempty{#3}% last field
        {\@parselabelspec@field@label=#2()\end#4}%
        {\@parselabelspec@field#3X#4X=#2\end}%
    \fi
  \else% not a label field
    \@ifempty{#3}% last field
      {\@parselabelspec@field@label#5#6()\end#4\string|#1#2}%
      {\@parselabelspec@field#3X#4\string|#1#2X#5#6\end}%
   \fi
}

\def\@parselabelspec@field@label#1#2(#3)#4\end{%
  \if=#1% label found
    \@ifempty{#2}% check there's nothing between = and offset
      {\@ifempty{#3}% 
        {incrlabel@action\string @*}% no offset
        {incrlabel@action\string @#3}% place offset as number
    }{%
      \PackageError{beamincr}{Label action field contains extra text: #2}{}%
    }%
  \else% no label -- gobble the following | character
    \x@\@gobblepipe%
  \fi
}
\def\@gobblepipe#1|{}


%% \parsedefincspec - parse default spec inclusion

% parse | segements
\def\parsedefincspec#1{%
  \@parsedefincspec@field#1|X%
}
% #1: first token of field
% #2: rest of field
% #3: rest of spec
\def\de@ngle<#1>{#1}
\def\@parsedefincspec@field#1#2|#3X{%
  \ifx ~#1\x@\@firstoftwo\else\x@\@secondoftwo\fi% if field starts with @
    {\x@\de@ngle\beamer@defaultospec}%insert default spec
    {#1#2}%copy field
  \@ifempty{#3}% last field
    {}%
    {|\@parsedefincspec@field#3X}%
}

%% 
%% install overlay parsing in beamer commands
%%

% this involves some minor hackery: the idea is to redefine the macro
% \beamer@masterdecode (which seems to be the top level call to parse overlay
% specs) to first parse the incr refs and then call beamer's original parser.

% save the original beamer overlay processor
\let\beamer@masterdecode@orig=\beamer@masterdecode
% now replace it, calling the old one
\def\beamer@masterdecode#1{%
  \edef\parsed@spec{\parsedefincspec{#1}}%
  \edef\parsed@spec{\x@\parseincrspec\x@{\parsed@spec}}%
  \edef\parsed@spec{\x@\parseresetspec\x@{\parsed@spec}}%
  \edef\parsed@spec{\x@\parselabelspec\x@{\parsed@spec}}%
  \debug@message{masterdecode: <#1> -> <\parsed@spec>^^J}%
  \x@\beamer@masterdecode@orig\x@{\parsed@spec}%
}%


%% 
%% \againframe and variants
%%


%% modify the beamer code to:
% (1) parse incrrefs  (but no other extensions) in the frame spec
% (2) turn  framescanonly off and back on

% \def\againframe{\@ifnextchar<{\beamer@againframe}{\beamer@againframe<*>}}
% \def\beamer@againframe<#1>{\@ifnextchar[{\beamer@@againframe<#1>}{\beamer@@againframe<#1>[]}}
% \def\beamer@@againframe<#1>[{\@ifnextchar<{\beamer@@@@againframe<#1>[}{\beamer@@@againframe<#1>[<*>][}}
% \def\beamer@@@@againframe<#1>[#2]{\@ifnextchar[{\beamer@@@againframe<#1>[{#2}]}{\beamer@@@againframe<#1>[{#2}][]}}

\let\beamer@@@againframe@orig=\beamer@@@againframe
\def\beamer@@@againframe<#1>[#2][#3]#4{%
  \edef\@scanstate{\@ifallowscanonlystate}%
  \allowframescanonly0%
  \beamer@@@againframe@orig<\parseincrspec{#1}>[#2][#3]{#4}%
  \x@\allowframescanonly\@scanstate%
}



%% Access the *contents* of a previously defined frame.  Allows more fine-grained access, changes etc.
\newcommand{\againframebody}[1]{%
  \@ifundefined{beamer@again@#1}%
  {\ClassError{beamer}{No frame has been designated to resume under
      the name "#1"}{}}%
  \x@\csname beamer@again@#1\endcsname%
}

%% Run a frame again, with new title.  Original definition MUST use \frametitle (not an arg to \begin{frame})
% \begin{frame}[label=foo]\frametitle{first title}\end{frame}
% \againframeretitle{foo}{second title}
% The new title will overwrite the stored one, and appear in subsequent calls to
% \againframe

\def\againframeretitle{\@ifnextchar<{\beamer@againframeretitle}{\beamer@againframeretitle<*>}}
\def\beamer@againframeretitle<#1>{\@ifnextchar[{\beamer@@againframeretitle<#1>}{\beamer@@againframeretitle<#1>[]}}
\def\beamer@@againframeretitle<#1>[{\@ifnextchar<{\beamer@@@@againframeretitle<#1>[}{\beamer@@@againframeretitle<#1>[<*>][}}
\def\beamer@@@@againframeretitle<#1>[#2]{\@ifnextchar[{\beamer@@@againframeretitle<#1>[{#2}]}{\beamer@@@againframeretitle<#1>[{#2}][]}}
\def\beamer@@@againframeretitle<#1>[#2][#3]#4#5{%
  \@ifundefined{beamer@again@#4}%
  {\ClassError{beamer}{No frame has been designated to resume under
      the name "#4"}{}}%
  {%
  \def\beamer@temp{\begin{frame}<\parseincrspec{#1}>[#2][{#3},relabel=#4]{}{}}%
  \x@\let\x@\beamer@templet\csname beamer@again@#4\endcsname%
  \x@\beamer@temp\beamer@templet\frametitle{#5}\end{frame}}%
}


%% 
%% \handoutframe - show specific overlay stage(s) in handout.
%%

% The handout and trans modes usually "flatten" all the overlays of a
% frame.  This may not be desirable, for example when text has been
% replaced, rather than augmented.  \handoutframe is a wrapper
% to \againframe that only runs in handout mode, and temporarily
% switches to presentation mode to allow specific frames to be
% rendered as they would be onscreen.  With optional argument, does
% the same for other modes (e.g. trans).

% Example:
% \begin{frame}<handout:0>[label=complexframe]complex stuff\end{frame}
% \handoutframe<2,5-6>{complexframe}

% Idea from:
% https://tex.stackexchange.com/questions/455444/beamer-overlays-and-handout-exclude-frames-from-handout/455459#455459
% but a different interface.

% as we need to reset the mode (or end a group) after the \againframe call we
% need to parse and pass to \againframe all potential arguments.  So we follow
% the \againframe definition from beamer.
\newcommand\handoutframe[1][handout]{% check for <spec>
  \@ifnextchar<{\handoutframe@[#1]}{\handoutframe@[#1]<*>}%
}
\def\handoutframe@[#1]<#2>{% check for [opt]
  \@ifnextchar[{\handoutframe@@[#1]<#2>}{\handoutframe@@[#1]<#2>[]}%
}
\def\handoutframe@@[#1]<#2>[{%check if opt is [<def>]
  \@ifnextchar<{\handoutframe@@@[#1]<#2>[}{\handoutframe@do[#1]<#2>[<*>][}%
}
\def\handoutframe@@@[#1]<#2>[#3]{%read [<def>] and check for [opt]
  \@ifnextchar[{\handoutframe@do[#1]<#2>[{#3}]}{\handoutframe@do[#1]<#2>[{#3}][]}%
}
\def\handoutframe@do[#1]<#2>[#3][#4]#5{%
  \mode<#1>{%
%    grouping seems to be enough, but also possible to explicitly save
%    and restore current mode if necessary.
%    \edef\save@currentmode{\beamer@currentmode}
    \begingroup
    \def\beamer@currentmode{beamer}%
    % we've parsed all the arguments, so just call the inner function
    \beamer@@@againframe<#2>[{#3}][#4]{#5}%
    \endgroup
%    \edef\beamer@currentmode{\save@currentmode}%
  }%
}


%% 
%% \framescanonly 
%% 
% This command is similar to a <0> argument to \begin{frame} in that it
% suppresses the frame output.  But the frame is still scanned and so increment
% labels are available for use with \againframe or \handoutframe.

% Protect \mode from expansion as frame scans input.   If expanded then the
% effective mode would be frozen at first expansion, fouling \handoutframe's
% mode switch
\protected\def\beamincr@protected@mode{\mode}

\newcommand<>\framescanonly{%
  \if@allowscanonly%
  \beamincr@protected@mode#1{%
    \@ifundefined{AddToHookNext}%
      {\PackageWarning{beamincr}{\framescanonly is not supported in this LaTe\stringX version}}%
      {\AddToHookNext{shipout/before}{\DiscardShipoutBox}}%
  }%
  \fi
}

\newif\if@allowscanonly
\def\allowframescanonly#1{\ifnumgreater{#1}{0}{\@allowscanonlytrue}{\@allowscanonlyfalse}}
\@allowscanonlytrue
\def\@ifallowscanonlystate{\if@allowscanonly1\else0\fi}




%% 
%% incremental[do] environments
%%

\newenvironment{incremental}{%
  \let\incremental@do\relax\Collect@Body\@incremental%
}{\ignorespacesafterend}

\let\@endnext\relax
\newenvironment{incrementaldo}[1]{%
  \x@\long\x@\def\x@\incremental@do##1\@endnext{#1}\Collect@Body\@incremental%
}{\ignorespacesafterend}
\@incremental@env@angles{do}

\newenvironment{incrementaldocmd}[2][0]{%
  \x@\newcommand\x@\incremental@do\@firstofone{[#1]{#2}}\Collect@Body\@incremental%
}{\ignorespacesafterend}

\newenvironment{incrementaldodef}[2][]{%
  \x@\def\x@\incremental@do#1{#2}\Collect@Body\@incremental%
}{\ignorespacesafterend}

\newenvironment{incrementaldolongdef}[2][]{%
  \x@\long\x@\def\x@\incremental@do#1{#2}\Collect@Body\@incremental%
}{\ignorespacesafterend}

\newcounter{next}

%% incremental[do] internals

% process the body of environment
\long\def\@incremental#1{%
  \setcounter{next}{0}%
  \@incremental@optspec#1\nextX% ungroup and terminate input
}

% environment option default spec
\newcommand\@incremental@optspec[1][\beamer@defaultospec]{%
  \edef\beamer@defaultospec{#1}% set beamer@defaultospec locally
  \@incremental@firstfield%
}

% #1: field to first \next
% #2: remaining fields including terminal \next
\long\def\@incremental@firstfield#1\next#2X{%
  \ifwhitespace{#1}%
    {\stepcounter{next}\@incremental@next@chkstar#2X}        % skip if nothing before first \next
    {\@incremental@next@spec@nocmd#1\next#2X}%
}

% check for starred \next => no command
\def\@incremental@next@chkstar{%
  \@ifstar{\@incremental@next@spec@nocmd}{\@incremental@next@spec}%
}

% check for overlay spec within the field
\def\@incremental@next@spec@nocmd{%
  \@ifnextchar<%input starts with overlay spec char
    {\@incremental@do@next@nocmd}%
    {\x@\@incremental@do@next@nocmd\beamer@defaultospec}%
}
% #1: spec
% #2: field contents
% #3: remaining fields
\long\def\@incremental@do@next@nocmd<#1>#2\next#3X{%
    \action<#1>{#2}%
    \@ifempty{#3}%
      {}% done
      {\stepcounter{next}\@incremental@next@chkstar#3X}%
}


\def\@incremental@next@spec{%
  \@ifnextchar<%input starts with overlay spec char
    {\@incremental@do@next}%
    {\x@\@incremental@do@next\beamer@defaultospec}%
}
% #1: spec
% #2: field contents
% #3: remaining fields
\long\def\@incremental@do@next<#1>#2\next#3X{%
    \action<#1>{\incremental@do#2\@endnext}%
    \@ifempty{#3}%
      {}% done
      {\stepcounter{next}\@incremental@next@chkstar#3X}%
}



%% 
%% create increment-aware alignment environments
%%

%% user-facing incremental align commands

%% \CreateIncrementalAlignEnvironment{name}[Nopts]{Nargs}[defaultspec]
% Create an incremental version of the named environment.  The new
% environment is accessible as either {incrementalname} or {name<>}.

\newcommand\CreateIncrementalAlignmentEnvironment[1]{%
  \@ifnextchar[{\@createincralign@opt{#1}}{\@createincralign@opt{#1}[0]}
}
\def\@createincralign@opt#1[#2]#3{%
  \@ifnextchar[{\@createincralign#1[#2]#3}{\@createincralign#1[#2]#3[<.->]}%
}
  

% \setincrementalenvspec{name}{<spec1>&<spec2>...}
\def\setincrementalenvspec#1#2{%
  \gcsdef{@incralign@#1@defaultspec}{#2}%
}

% 
\newcommand\useincrementalenv[1]{%
  \ifcsdef{incremental#1}{%
    \csgdef{#1}{\csname incremental#1\endcsname}%
    \csgdef{end#1}{\csname endincremental#1\endcsname}%
  }{%
    \PackageError{beamincr}{Incremental #1 environment not created}{}%
  }
}

\newcommand\usenonincrementalenv[1]{%
  \ifcsdef{#1@orig}{%
    \csgdef{#1}{\csname #1@orig\endcsname}%
    \csgdef{end#1}{\csname end#1@orig\endcsname}%
  }% fail silently if not defined
}




%% Incremental alignment environment internals

% token register to collect the processed toks               
\newtoks\@incraligntoks

\def\@createincralign#1[#2]#3[#4]{%
  \global\csletcs{#1@orig}{#1}%
  \global\csletcs{end#1@orig}{end#1}%
  \csdef{@incralign@#1@numopt}{#2}
  \csdef{@incralign@#1@numarg}{#3}
  \csdef{@incralign@#1@defaultspec}{#4}
  \newenvironment{incremental#1}{%
    \def\@incralign@this####1{\@incralign[#1]{####1}}%
    \collect@body\@incralign@this}{}%
  \csletcs{#1<>}{incremental#1}%
  \csletcs{end#1<>}{endincremental#1}%
}

\def\@incralign[#1]#2{%
  \@incraligntoks={}% clear processed token list
  \debug@message{send to incralign@process: \unexpanded{#2}\\X^^J}%
  \@incralign@readargs{#1}{\csuse{@incralign@#1@numopt}}{\csuse{@incralign@#1@numarg}}#2\\X% process raw body token by token (\\ added to last line wiill be removed)
  \debug@message{send to #1: \the\@incraligntoks^^J}%
  \def\beginenv{\begin{#1@orig}}% needed for \expandafter
  \x@\beginenv% pass expanded token list to base environment
    \the\@incraligntoks
  \end{#1@orig}%
}


% read any environment arguments and default spec
% #1 - environment name
% #2 - number of optional args left
% #3 - number of required args left
\def\@incralign@readargs#1#2#3{%
  \ifnumgreater{#2}{0}% any remaining optional args?
    {% check for one, if missing then no more optional args
      \@ifnextchar[{\@incralign@readoptarg{#1}{#2}{#3}}{\@incralign@readargs{#1}{0}{#3}}%
    }{%
        \ifnumgreater{#3}{0}% any remaining required args?
         {% read one
           \@incralign@readreqarg{#1}{#2}{#3}%
         }{% read the default spec and process the body
           \@ifnextchar[%
             {\@incralign@process@line}%
             {\x@\x@\x@\@incralign@process@line\x@\x@\x@[\csname @incralign@#1@defaultspec\endcsname]}%
         }
    }
}

\def\@incralign@readoptarg#1#2#3[#4]{%
  \iffirst<{#4}%
    {\ifnumgreater{#3}{0}%
      {\PackageError{beamincr}{Default spec appears before last reqd arg in #1<>}{}}%
      {\@incralign@readargs{#1}{0}{0}[#4]}%
    }{%
      \@incraligntoks=\x@{\the\@incraligntoks [#4]}%
      \@incralign@readargs{#1}{\numexpr #2 - 1\relax}{#3}%
    }%
}
\def\@incralign@readreqarg#1#2#3#4{%
  \iffirst[{#4}% looks like an opt arg
    {\PackageError{beamincr}{Too many optionals or default spec appears before last reqd arg in #1<>}{}}%
    {\@incraligntoks=\x@{\the\@incraligntoks {#4}}%
      \@incralign@readargs{#1}{#2}{\numexpr #3 - 1\relax}}%
}

%% main processing loop

% process line-by-line
% #1: increment spec
% #2: this line
% #3: remaining lines  
\def\@incralign@process@line[#1]#2\\#3X{%
   \@ifempty{#3}%
     {\@ifempty{#2}% 
         {}% there was nothing after last \\ in body -- done
         {\@incralign@process@field[#1]#1&X#2&\\#3X}%
     }{%
       \@incralign@process@field[#1]#1&X#2&\\#3X%
     }%
}

% process next field
% #1: full spec
% #2: spec to next &
% #3: remaining spec
% #4: remaning body
\def\@incralign@process@field[#1]#2&#3X#4X{%
  \@incralign@field@optspec[#1][#2][#3]#4X%
}

% check for overlay spec within the field
% #1: full spec
% #2: spec for this field
% #3: remaining spec
\def\@incralign@field@optspec[#1][#2][#3]{%
  \@ifnextchar<%input starts with overlay spec char
    {\@incralign@do@field[#1][#3][#2]}%
    {\@incralign@do@field[#1][#3][#2]#2}%
}

% process field teminated by &
% #1: full spec
% #2: remaining spec
% #3: default spec for this field
% #4: spec for this field
% #5: field contents
% #6: remaining line
% #7: remaining body
\def\@incralign@do@field[#1][#2][#3]<#4>#5&#6\\#7X{%
  \@incraligntoks=\x@{\the\@incraligntoks \def\beamer@defaultospec{#3}\action<#4>{#5}}%
  \@ifempty{#6}%
     {% reached last field on line
        \@ifempty{#7}{}% no more lines (so eol \\ was appended) - we're done
          {% else terminate line and check for optional arg
            \@incraligntoks=\x@{\the\@incraligntoks \\}%
            \@incralignbreak@checkopt#7X#1X% check for optional arg after \\
          }%
     }{% else more fields
        \@incraligntoks=\x@{\the\@incraligntoks &}%
        \@ifempty{#2}% reuse fullspec if we've exhausted the current one
          {\@incralign@process@field[#1]#1&X#6\\#7X}%
          {\@incralign@process@field[#1]#2X#6\\#7X}%
     }%
}

% check for optional arg after break
\def\@incralignbreak@checkopt{%
  \@ifnextchar[%
    {\@incralignbreak@getopt}%
    {\@incralignbreak@noopt}%
}

% no optional arg after break: just process
% #1: rest of body
% #2: full spec
\def\@incralignbreak@noopt#1X#2X{%
  \@incralign@process@line[#2]#1X%
}

% read optional arg after break
% #1: opt arg
% #2: rest of body
% #3: full spec
\def\@incralignbreak@getopt[#1]#2X#3X{%
  \@incraligntoks=\x@{\the\@incraligntoks [#1]}%
  \@incralign@process@line[#3]#2X%
}
      

%% 
%% create a few aligned environments by default
%%

\CreateIncrementalAlignmentEnvironment{align*}{0}[<+->&<.->&<.->&<.->&<.->&<.->&<.->&<.->]
\CreateIncrementalAlignmentEnvironment{align}{0}[<+->&<.->&<.->&<.->&<.->&<.->&<.->&<.->]
\CreateIncrementalAlignmentEnvironment{gather}{0}[<+->]
\CreateIncrementalAlignmentEnvironment{gather*}{0}[<+->]
\CreateIncrementalAlignmentEnvironment{tabular}[1]{1}[<+->&<.->&<.->&<.->&<.->&<.->&<.->&<.->]
\CreateIncrementalAlignmentEnvironment{tabular*}[1]{2}[<+->&<.->&<.->&<.->&<.->&<.->&<.->&<.->]


%%

\@ifpackageloaded{tikz}{

\newenvironment{incrementallayers}[1][]{%
  % if the optional arg contains an overlay spec, 
  \iffirst<{#1}{\def\beamer@defaultospec{#1}}{\tikzset{incremental layer/.append style={#1}}}
  \x@\long\x@\def\x@\incremental@do##1\@endnext{\node[#1]{{##1}};}
     \Collect@Body\@incrementallayers%
}{\ignorespacesafterend}

\tikzset{incremental layer/.style={}}

\newcommand\@incrementallayers[1]{%
  \begin{tikzpicture}[%
      t/.style={anchor=north},
      c/.style={anchor=center},
      b/.style={anchor=south},
      every node/.style={text width=\columnwidth,inner sep=0pt,t,incremental layer}]
    \@incremental{#1}
  \end{tikzpicture}
}

\long\def\@incremental@layer@cmd#1{%
  \iffirst[{#1}{\@incremental@layer@cmd@opt#1X}{\@incremental@layer@cmd@opt[]#1X}
}
\long\def\@incremental@layer@cmd@opt[#1]#2X{%
  \node[#1]{#2}; 
  % global options installed by every node style;  
}



} %% end tikz-dependent extensions

\catcode`X=11

               
               
