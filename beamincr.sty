% beamincr.sty
% enhancements to beamer increment handling

\RequirePackage{etoolbox} % beamer uses this anyway
\RequirePackage{environ} % for long Collect@Body

% change category of X to other, so it can be used to separate arguments without interference from
% Xs in the input.  this means we can't use X as a letter in this file.
\catcode`X=12

% string form of @
\newcommand\at{\string @}

% abbreviate \expandafter
\let\x@=\expandafter

% if #1 is empty or whitespace (incl \par) -> #2 else -> #3
\long\def\ifwhitespace#1#2#3{\@ifwhitespace#1\parX{#2}{#3}}
\long\def\@ifwhitespace#1\par#2X#3#4{%
  \@ifempty{#1}{\@ifempty{#2}{#3}{\@ifwhitespace#2X{#3}{#4}}}{#4}%
}

% compare #1 to first token of #2, if equal -> #3 else ->#4
\long\def\iffirst#1#2#3#4{\@ifempty{#2}{#4}{\@iffirst#1#2X{#3}{#4}}}
\long\def\@iffirst#1#2#3X#4#5{\if#1#2\x@\@firstoftwo\else\x@\@secondoftwo\fi{#4}{#5}}

% remove angle brackets
\def\de@ngle<#1>{#1}

% choose the first line to get debugging messages on screen and log
\def\beamincrdebug#1{%
  \ifnumgreater{#1}{0}%
    {\gdef\debug@message{\message}}
    {\gdef\debug@message{\@gobble}}
}
\beamincrdebug0

\def\frame@nameornumber{\x@\ifblank\x@{\beamer@againname}{\insertframenumber}{\beamer@againname}}


%% 
%% allow references to future labels
%%

% if true, (currently) undefined labels will resolve to 0 rather than raising an error
\newif\if@allowundefincrref
\newcommand\allowundefinedincrrefs[1][1]{%
  \ifnumgreater{#1}{0}{\@allowundefincrreftrue}{\@allowundefincrreffalse}%
}





%% 
%% \resetincr[refspec] - (re)set the increment counter
%%

\newcounter{beamincr@lastreset}[framenumber] % reset for each  frame
\resetcounteronoverlays{beamincr@lastreset}

\def\resetincr{%
  \@ifnextchar<%
    {\resetincr@angle}% called as action
    {\resetincr@normal}%
}

\newcommand\resetincr@normal[1][1]{%
  \@resetincr{\parseincrspec{#1}}%
}

% action form -- not for users
% beamer actions are documented to always call environments, but
% sometimes call commands instead.
\newenvironment<>{resetincrenv}{\resetincr#1}{}

\def\resetincr@angle<#1:#2>{% called as action
  \debug@message{action: setting increment to #2^^J}%
  \@resetincr{#2}% ignore the mode -- always "all"
}
\def\@resetincr#1{%
  \debug@message{resetincr: setting current increment to #1^^J}%
% etoolbox defcounter allows inline calculation, but local by default
  \ifnumgreater{#1}{0}%
    {\global\defcounter{beamerpauses}{#1+1}}%
    {\global\defcounter{beamerpauses}{#1}}%
  \global\defcounter{beamincr@lastreset}{#1}%
}


%%
%% \fromincr<refspec> - set the increment counter and place following text on corresponding slide
%% 
  
\def\fromincr<#1>{%
  \resetincr[#1]%
  \onslide<.->\relax%
}

%% 
%% \incrlabel - increment labels
%%

% \incrlabel{foo} save the current "increment number" in the label 'foo' for
% reference with \incrref{foo} (and/or </foo/>).

% The "increment number" is defined by the use of \pause and relative overlay
% commands like \onslide<+->.  In general, it corresponds to the slide on which
% text that follows a <.> increment would appear.  For technical reasons this is
% one less than the value of the beamerpauses counter (unless that counter is
% 1).  This can cause confusion if \pause and <+> constructs are mixed.

% the internal label name includes the frame label if one is given -- this helps
% to keep the references valid across frames

%% current increment = max(1,\value{beamerpauses}-1) as a numeric value
\newcommand\@currentincr{%
  \ifnumless{1}{\c@beamerpauses}%
    {\number\numexpr\c@beamerpauses - 1\relax}%
    {\thebeamerpauses}%
}

%% user accessible version -- smells like a counter
\newcommand\theincrement{\@currentincr}

%% \incrlabel{label} - set label to current increment
%% \incrlabel<refspec>{label} - set label to increment evaluated from refspec

\newcommand\incrlabel{%
  \@ifnextchar<{\incrlabel@angle}{\incrlabel@normal}%
}
\newcommand\incrlabel@normal[1]{%
  \incrlabel@do{#1}{\@currentincr}%
}
\def\incrlabel@angle<#1>#2{%
  \incrlabel@do{#2}{\parseincrspec{#1}}%
}
\def\incrlabel@do#1#2{%
  \ifstrequal{=}{#1}{% \incrlabel[<>]=/foo/
    \@incrlabel@equals@futureget<#2>%
  }{\ifstrequal{/}{#1}{% \incrlabel[<>]/foo/
      \@incrlabel@equals@futureget<#2>/%
    }\iffirst({#1}{% \incrlabel[<>]{(offset)foo}
      \incrlabel@do@#1X{#2}%
    }{% \incrlabel[<>]{foo}
      \incrlabel@do@(0)#1X{#2}%
    }%
  }%
}
\def\@incrlabel@equals@futureget<#1>#2/#3/{%
  \@ifempty{#3}%
    {#2}% ignore silently if label empty
    {\incrlabel@angle<#1>{#3}%
      #2%
    }%
}

\def\incrlabel@do@(#1)#2X#3{%
  \csxdef{beamincr@\frame@nameornumber @#2}{\the\numexpr #1+#3\relax}%
}


%% \incrlabelcode[frame]{label}{code} - execute code when label evaluated
\newcommand\incrlabelcode[3][\frame@nameornumber]{%
  \csgdef{beamincr@#1@#2}{#3}%
}

%% 
%% built-in labels
%%

%% . -> current increment
\incrlabelcode[global]{.}{\@currentincr}

%% ! -> last reset increment
% (protect to delay expansion of reset counter until evaluation)
% use local offset processing -- else \@@incrref@offset would force expansion
\protected\def\beamincr@lastreset#1{%
  % At one point beamer \futurelets \next=\beamincr@lastreset, calls \ifcat\next a, which evaluates
  % \beamincr@lastreset{a}, which fails as a is not a number.  Test specifically for this case.
  \if a#1 0a\else
    \ifnumequal{\c@beamincr@lastreset}{0}% ignore offset if reset to 0
      {0}{\the\numexpr #1+\c@beamincr@lastreset\relax}%
  \fi%
}
\csdef{beamincr@global@!@offsetcode}{\beamincr@lastreset}

%% various overlay counting labels
\AtBeginEnvironment{beamer@framepauses}{%
  %% @ -> current overlay number
  \incrlabel<\beamer@overlaynumber>{@}%
  %% ^ -> first overlay used
  \ifcsdef{beamincr@\frame@nameornumber @^}{%
    \edef\current@first{\csuse{beamincr@\frame@nameornumber @^}}%
    \ifnumless{\beamer@overlaynumber}{\current@first}{\incrlabel<\beamer@overlaynumber>{^}}{}%
  }{\incrlabel<\beamer@overlaynumber>{^}}%
  %% $* -> last overlay used so far
  \edef\current@end{\csuse{beamincr@\frame@nameornumber @$*}}%
  \ifnumgreater{\beamer@overlaynumber}{0\current@end}{\incrlabel<\beamer@overlaynumber>{$*}}{}%
  %% $ -> last overlay number -- initialised from aux but increment if exceeded
  \edef\current@end{\csuse{beamincr@\frame@nameornumber @$}}%
  \ifnumgreater{\beamer@overlaynumber}{0\current@end}{\incrlabel<\beamer@overlaynumber>{$}}{}%
  %% add frame to list of framenames (to write $ defns to aux at end)
  \xifinlist{\frame@nameornumber}{\beamincr@framelist}{}{\listxadd{\beamincr@framelist}{\frame@nameornumber}}% 
}

%% write out the $ defns for all frames to aux
\def\beamincr@framelist{}% initialise list
\AtEndDocument{%
  \renewcommand*\do[1]{%
    % use $* (not $) otherwise $ would never be reduced
    \immediate\write\@auxout{\string\csgdef{beamincr@#1@$}{\csuse{beamincr@#1@$*}}}%
  }\dolistloop{\beamincr@framelist}%
}




%% \incrlabel@action is called using a |= action
% the action is placed at the beginning of the calling spec, which means it
% should be (almost) innermost, its argument containing only
% {\uncover<spec>{text of action}}.
% We need to read the label from inside the text.

% #1: spec
% #2: arg = {\uncover<spec>{text}}
\long\def\incrlabel@action<#1>#2{%
  \x@\@incrlabel@action@parse\@incrlabel@action@unbracearg#2//X<#1>X%
}
% expose contents of grouped text arg
\long\def\@incrlabel@action@unbracearg#1<#2>#3{%
  #1<#2>#3% removes {} from #3
}

% #1: \uncover
% #2: uncover spec
% #3: text before label
% #4: label
% #5: text after label
% #6: mode spec to = action (always 'all')
% #7: numeric spec to = action
\long\def\@incrlabel@action@parse#1<#2>#3/#4/#5X<#6:#7>X{%
  \@ifempty{#4}%
    {}%#1<#2>{#3 \@dropslashslashxx#5XX}}% ignore silently if label missing
    {\debug@message{action: setting label /#4/=\@currentincr+#7^^J}%
      \ifx*#7%
        \incrlabel{#4}%
      \else%
        \incrlabel</.(#7)/>{#4}%
      \fi%
    }%
    \@ifempty{#5}%
      {\def\remain{}}%  no /s in input: terminal //s removed
      {\long\edef\remain{\expandonce{\@dropslashslashxx#5XX}}}% /{}/ in input, copy remaining arg and drop terminator
    \long\def\put##1{#1<#2>{#3##1}}%
    \x@\put\x@{\remain}%
}
\long\def\@dropslashslashxx#1//XX{#1}

% the environment form will be called
% as \begin{incrlabel@actionenv}<spec>\begin{uncoverenv}<spec>text\end...
% \collect@body seems not to work this deep inside beamer environments.  So in
% this case, we just read to the first /.../.  If there isn't one this will
% generate a (somewhat interpretable) error.
\newenvironment<>{incrlabel@actionenv}{\@incrlabel@actionenv@#1}{}

\def\@incrlabel@actionenv@<#1:#2>{%
  \ifx*#2\x@\@firstoftwo\else\x@\@secondoftwo\fi
    {\@incrlabel@equals@futureget</./>}
    {\@incrlabel@equals@futureget</.(#2)/>}
}

\def\@incrlabel@action@futureget<#1:#2>#3/#4/{%
  \@ifempty{#4}%
    {#3}% ignore silently if label missing
    {\debug@message{actionenv: <#1:#2> setting label /#4/=\@currentincr+#2^^J}%
      \ifx*#2%
        \incrlabel{#4}%
      \else
        \incrlabel</.(#2)/>{#4}%
      \fi
      #3%
    }%
}


%% \incrref{label} - print the incr number associated with label in the current frame
%% \incrref[framename]{label} - reference a different frame
%% \incrref{label(offset)} - add a numerical offset, possibly negative.

% The tricky part is the optional offset.  The idea is to use a helper function
% to call the main parser (\def'd to expect parens) with trailing ().  If there
% were parens in the label, the parser will see them first, and use
% \@gobbleparens to throw away the trailing ones (and any text between the real
% ones and the trailers).  If not, the parser sees an empty arg between the
% parens and knows to ignore it.


\newcommand\incrref[2][\frame@nameornumber]{%
  \@incrref[#1]#2()%
}
\def\@incrref[#1]#2(#3){%
  \@ifempty{#3}%
   {\@@incrref[#1]#2(0)}%
   {\@@incrref[#1]#2(#3)\@gobbleparens}%
}
\def\@gobbleparens#1(){}

\def\@@incrref[#1]#2(#3){%
  \ifcsdef{beamincr@#1@#2}% check for frame-local label defn
    {\x@\@@incrref@offset\x@{\csname beamincr@#1@#2\endcsname}{#3}}%
    {\ifcsdef{beamincr@global@#2}% then for global defn (usually code)
      {\@@incrref@offset{\csuse{beamincr@global@#2}}{#3}}%
      {\ifcsdef{beamincr@global@#2@offsetcode}% then for offset processing code
        {\csuse{beamincr@global@#2@offsetcode}{#3}}%
        {\if@allowundefincrref\x@\@firstoftwo\else\x@\@secondoftwo\fi
          {0}%
          {\PackageError{beamincr}{No label #2 in frame #1}{}}%
        }%
      }%
    }%
}

% no offset on 0 increments
\def\@@incrref@offset#1#2{\ifnumequal{#1}{0}{0}{\number\numexpr #1+#2\relax}}


%%
%% change subsequent default spec from within action
%%

\newcommand<>\defaultspec[1]{\def\beamer@defaultospec{#2} #1}
\newenvironment<>{defaultspecenv}{\def\beamer@defaultospec{#1}}{\ignorespacesafterend}

%% 
%% alerts
%%

% \alert or \alert*
\let\@alert@orig=\alert
\def\alert{\@ifstar{\@alert@star}{\@alert@orig}}
\newcommand<>\alerts[1]{{\@alerts@activate{#2}#1}}%
\newenvironment<>{alertsenv}{\@alerts@activate{#1}}{\ignorespacesafterend}
\let\@alertnow=\relax
\def\@alerts@activate#1{\alt#1{\let\@alertnow=\@alert@orig}{\let\@alertnow=\relax}}
\def\@alert@star#1{\@alertnow{#1}}

%% 
%% pointers
%%

% \point and \point* and point@spec
\newcommand\point{%
  \@ifstar{\@point@star}{\@point}%
}
\newenvironment<>{pointenv}{\@@point{#1}}{\ignorespacesafterend}% environment groups for us

% pointers@spec (\pointers use is available but undocumented)
\newcommand<>\pointers[1]{%
  {\@pointersactivate{#2}#1}%% group to prevent \point* activation out of scope
}
\newenvironment<>{pointersenv}{\@pointersactivate{#1}}{\ignorespacesafterend}% environment groups for us

% pointer configuration
\newcommand\usepointer[2][@]{%
  \def\@pointon{\@pointer@set{#2}}%
  \ifstrequal{#1}{@}% @_11 shouldn't be used by user -- implies use phantom
    {\def\@pointoff{\@pointer@set{\phantom{#2}}}}%
    {\def\@pointoff{\@pointer@set{#1}}}%
}
\usepointer{\raisebox{0.3ex}{\alert{$\blacktriangleright$}}}
% another choice: needs {bbding}
% \usepointer{\raisebox{-0.4ex}{\alert{\HandRight}}}

\newcommand\useoverprintpointer{\def\@pointer@set##1{\makebox[0pt][r]{##1}}}
\newcommand\useuncoverpointer{\def\@pointer@set{}}
\useoverprintpointer


% internals

% \point* - place pointers within text (or tikz)
\def\@point@star{%
  \@ifnextchar[{\pointtonode}{%
    \@ifnextchar\bgroup{\pointtonode}{\@pointnow}%
  }%
}
% non-tikz default, overridden in tikz section below  
\newcommand\pointtonode[2][]{\@pointnow{#1}}

% nonstarred \point
\newcommand<>\@point[1]{%
  {\@@point{#2}#1}% group with argument to prevent \point* activation out of scope
}

\let\@pointnow\@pointoff % turn off any \point* used outside \point[ers] scope

\def\@pointersactivate#1{\alt#1{\let\@pointnow=\@pointon}{\let\@pointnow=\@pointoff}}%

\def\@@point#1{%
  \@pointersactivate{#1}%
  % context-dependent pointer placement
  % tikz has disabled \iftikz@inside@picture so instead test for \useasboundingbox
  \ifdef{\useasboundingbox}{}% no pointer in tikz
    {% not in tikz
      % check for lists -- this code will fail if itemize is nested under enum
      \ifnumgreater{\@listdepth}{0}% if in a ilst
        {\ifnumgreater{\@enumdepth}{0}% if in enumerate
          % put pointer before enum label (\only barfs on edef)
          {\only#1{\x@\def\x@\@itemlabel\x@{\x@\@pointnow\@itemlabel}}}
          {\ifnumgreater{\@itemdepth}{0}% if in itemize
            {\only#1{\def\@itemlabel{\@pointnow}}}% put pointer in the item label
            {}% if other list do nothing
        }}{% not in a list
          \@pointnow% print the pointer
    }}%
}


%%
%% overlay/action specification parsing
%%

%% \parseincrspec - parse /incrlabel/ refs
% \parseincrspec{spec} replaces incr labels within // chars with the
% corresponding values returned by \incrref.

% Again, we use a helper function that adds empty // chars to terminate the
% parser.  In this case we keep going until we hit the terminal //.

% start the parsing
\def\parseincrspec#1{%
  \@parseincrspec#1//%
}

% split input by /
% #1: input to first /
% #2: input to next /
\def\@parseincrspec#1/#2/{%
  #1% copy input to first /
  \@ifempty{#2}{}{% if empty we're done
    \@parseincrspec@handledash@protectoffset#2()X%
    \@parseincrspec% keep going
  }%
}


\def\@zer@orempty#1{\ifnum0=0#1 \x@\@firstoftwo\else\x@\@secondoftwo\fi{0}{}}

% need to parse any offet, in case it's negative (and so has a '-')
\def\@parseincrspec@handledash@protectoffset#1(#2)#3X{%
  \@ifempty{#2}{%
    \@parseincrspec@handledash()X#1-X-%
  }{%
    \x@\@parseincrspec@handledash\@xcopytoparens{(#2)()X#1}#3-X-%
  }%
}
% de{}s first arg
\def\@xcopytoparens#1#2(){#1#2}

% foo -> Xfoo-X-  -> #2=foo #3=X
% -foo -> X-foo-X- ->#2={} #3=foo remaining X-
% foo- -> Xfoo--X- ->#2=foo #3={} remaining X-
\def\@parseincrspec@handledash#1X#2-#3-{%
  \@ifempty{#2}{% leading -, label in #3, gobble X-
    \@zer@orempty{\@incrref[\frame@nameornumber]#3#1}-\@incrref[\frame@nameornumber]#3#1%
    \@gobblexdash%
  }{%
    \@ifempty{#3}{% trailing -, label in #3, gobble X-
      \@incrref[\frame@nameornumber]#2#1-\@zer@orempty{\@incrref[\frame@nameornumber]#2#1}%
      \@gobblexdash%
    }{% no -, label in #2
      \@incrref[\frame@nameornumber]#2#1}% just resolve this ref
    }%
}
\def\@gobblexdash#1X-{}



%% \parseresetspec - parse !(incr) actions
\def\parseresetspec#1{%
  \@parseresetspec{}#1!X!XX% init: empty actions; input terminated by !X!XX
}

% split input by !
% #1: accumulated actions
% #2:input to first !
% #3:input to next !
\def\@parseresetspec#1#2!#3!{%
  #2%copy input to first !
  \ifX#3\x@\@firstoftwo\else\x@\@secondoftwo\fi
      {#1\x@\@gobbletoxx}%just print accumulated actions and remove the XX
      {\@parseresetspec@grabnum{#1}{}#3!}%else found !: grab the number at start of #3
}
\def\@gobbletoxx#1XX{}

% hack to test for digit
\def\ifisdigit#1{\ifcat_\ifnum9<1#1 _\else A\fi\x@\@firstoftwo\else\x@\@secondoftwo\fi}

% found a ! -- read the following number
% #1: accumulated actions
% #2: number so far
% #3: next token
% #4: remaining input to !
\def\@parseresetspec@grabnum#1#2#3#4!{% #1->accum actions #2->number so far #3->next token 
  \ifisdigit#3%
    {\@ifempty{#4}% no more input
       {\@@parseresetspec{#1}{#2#3}!}% number is #2#3
       {\@parseresetspec@grabnum{#1}{#2#3}#4!}}% check for more digits
    {\@ifempty{#2}%
       {\@parseresetspec{#1}#3#4!}% no number, just kill !
       {\@@parseresetspec{#1}{#2}#3#4!}}% number is #2
}

% got the number: create action and recurse
% #1: accumulated actions
% #2: increment number
% #3: rest of input to next !
\def\@@parseresetspec#1#2#3!{%
  #2%put count value on stream
  \@parseresetspec{#1|resetincr\at#2}#3!%add new action and parse remainder
}


%% \parselabelspec - parse |= actions

% parse | segements
\def\parselabelspec#1{%
  \@parselabelspec@field#1|XX.\end%
}
% #1: first token of field
% #2: rest of field
% #3: rest of spec
% #4: accumulated fields
% #5: label action fields
\def\@parselabelspec@field#1#2|#3X#4X#5#6\end{%
  \ifx=#1% field starts with =
    \ifx=#5 % already have a label
      \PackageError{beamincr}{Only one label action allowed in spec}{}%
    \else
      \@ifempty{#3}% last field
        {\@parselabelspec@field@label=#2()\end#4}%
        {\@parselabelspec@field#3X#4X=#2\end}%
    \fi
  \else% not a label field
    \@ifempty{#3}% last field
      {\@parselabelspec@field@label#5#6()\end#4\string|#1#2}%
      {\@parselabelspec@field#3X#4\string|#1#2X#5#6\end}%
   \fi
}

\def\@parselabelspec@field@label#1#2(#3)#4\end{%
  \if=#1% label found
    \@ifempty{#2}% check there's nothing between = and offset
      {\@ifempty{#3}% 
        {incrlabel@action\at*}% no offset
        {incrlabel@action\at#3}% place offset as number
    }{%
      \PackageError{beamincr}{Label action field contains extra text: #2}{}%
    }%
  \else% no label -- gobble the following | character
    \x@\@gobblepipe%
  \fi
}
\def\@gobblepipe#1|{}


%% \parseincludedefaultspec - parse default spec inclusion

% parse by | segements
\def\parseincludedefaultspec#1{%
  \@parseincludedefaultspec@field#1|X%
}
% #1: first field
% #2: rest of spec
\def\@parseincludedefaultspec@field#1|#2X{%
  \@parseincludedefaultspec@fieldtilde#1~X|#2X%
}
% #1: field to ~
% #2: field after ~
% #3: rest of spec
\def\@parseincludedefaultspec@fieldtilde#1~#2X|#3X{%
  #1% copy field to first ~
  \@ifempty{#2}{}% no tildes in field
   {\@iffirsttilde#2X% field ended with ~ or contained ~~
     {\@ifsecondempty#2X% ended ~
       {\x@\de@ngle\beamer@defaultospec}%insert default spec without <>s
       {\@putdefaultspecaction{#1}\x@\de@ngle\beamer@defaultospecX}
     }{%
       \@putdefaultspecaction{#1}\@copytotildetilde#2~X}%print the defaultspec@ action and copy the range
   }%
  \@ifempty{#3}{}%last field
   {|\@parseincludedefaultspec@field#3X}%
}

\def\@iffirsttilde#1#2X{\ifx~#1\x@\@firstoftwo\else\x@\@secondoftwo\fi}
\def\@ifsecondempty#1#2X{\@ifempty{#2}}
\def\@copytotildetilde#1~~{#1}
\def\@putdefaultspecaction#1#2X{#2|#1defaultspec\at#2}

%% 
%% install overlay parsing in beamer commands
%%

% this involves some minor hackery: the idea is to redefine the macro
% \beamer@masterdecode (which seems to be the top level call to parse overlay
% specs) to first parse the incr refs and then call beamer's original parser.

% save the original beamer overlay processor
\let\beamer@masterdecode@orig=\beamer@masterdecode
% now replace it, calling the old one
\def\beamer@masterdecode#1{%
  \edef\parsed@spec{\parseincludedefaultspec{#1}}%
  \edef\parsed@spec{\x@\parseincrspec\x@{\parsed@spec}}%
  \edef\parsed@spec{\x@\parseresetspec\x@{\parsed@spec}}%
  \edef\parsed@spec{\x@\parselabelspec\x@{\parsed@spec}}%
  \debug@message{masterdecode: <\unexpanded{#1}> -> <\parsed@spec>^^J}%
  \x@\beamer@masterdecode@orig\x@{\parsed@spec}%
}%


%% 
%% \againframe and variants
%%


%% modify the beamer code to:
% (1) parse incrrefs  (but no other extensions) in the frame spec
% (2) turn  framescanonly off and back on

% \def\againframe{\@ifnextchar<{\beamer@againframe}{\beamer@againframe<*>}}
% \def\beamer@againframe<#1>{\@ifnextchar[{\beamer@@againframe<#1>}{\beamer@@againframe<#1>[]}}
% \def\beamer@@againframe<#1>[{\@ifnextchar<{\beamer@@@@againframe<#1>[}{\beamer@@@againframe<#1>[<*>][}}
% \def\beamer@@@@againframe<#1>[#2]{\@ifnextchar[{\beamer@@@againframe<#1>[{#2}]}{\beamer@@@againframe<#1>[{#2}][]}}

\let\beamer@@@againframe@orig=\beamer@@@againframe
\def\beamer@@@againframe<#1>[#2][#3]#4{%
  \edef\@scanstate{\@ifallowscanonlystate}%
  \allowframescanonly0%
  \beamer@@@againframe@orig<\parseincrspec{#1}>[#2][#3]{#4}%
  \x@\allowframescanonly\@scanstate%
}



%% Access the *contents* of a previously defined frame.  Allows more fine-grained access, changes etc.
\newcommand{\againframebody}[1]{%
  \@ifundefined{beamer@again@#1}%
  {\ClassError{beamer}{No frame has been designated to resume under
      the name "#1"}{}}%
  \x@\csname beamer@again@#1\endcsname%
}

%% Run a frame again, with new title.  Original definition MUST use \frametitle (not an arg to \begin{frame})
% \begin{frame}[label=foo]\frametitle{first title}\end{frame}
% \againframeretitle{foo}{second title}
% The new title will overwrite the stored one, and appear in subsequent calls to
% \againframe

\def\againframeretitle{\@ifnextchar<{\beamer@againframeretitle}{\beamer@againframeretitle<*>}}
\def\beamer@againframeretitle<#1>{\@ifnextchar[{\beamer@@againframeretitle<#1>}{\beamer@@againframeretitle<#1>[]}}
\def\beamer@@againframeretitle<#1>[{\@ifnextchar<{\beamer@@@@againframeretitle<#1>[}{\beamer@@@againframeretitle<#1>[<*>][}}
\def\beamer@@@@againframeretitle<#1>[#2]{\@ifnextchar[{\beamer@@@againframeretitle<#1>[{#2}]}{\beamer@@@againframeretitle<#1>[{#2}][]}}
\def\beamer@@@againframeretitle<#1>[#2][#3]#4#5{%
  \@ifundefined{beamer@again@#4}%
  {\ClassError{beamer}{No frame has been designated to resume under
      the name "#4"}{}}%
  {%
  \def\beamer@temp{\begin{frame}<\parseincrspec{#1}>[#2][{#3},relabel=#4]{}{}}%
  \x@\let\x@\beamer@templet\csname beamer@again@#4\endcsname%
  \x@\beamer@temp\beamer@templet\frametitle{#5}\end{frame}}%
}


%% 
%% \handoutframe - show specific overlay stage(s) in handout.
%%

% The handout and trans modes usually "flatten" all the overlays of a
% frame.  This may not be desirable, for example when text has been
% replaced, rather than augmented.  \handoutframe is a wrapper
% to \againframe that only runs in handout mode, and temporarily
% switches to presentation mode to allow specific frames to be
% rendered as they would be onscreen.  With optional argument, does
% the same for other modes (e.g. trans).

% Example:
% \begin{frame}<handout:0>[label=complexframe]complex stuff\end{frame}
% \handoutframe<2,5-6>{complexframe}

% Idea from:
% https://tex.stackexchange.com/questions/455444/beamer-overlays-and-handout-exclude-frames-from-handout/455459#455459
% but a different interface.

% as we need to reset the mode (or end a group) after the \againframe call we
% need to parse and pass to \againframe all potential arguments.  So we follow
% the \againframe definition from beamer.
\newcommand\handoutframe[1][handout]{% check for <spec>
  \@ifnextchar<{\handoutframe@[#1]}{\handoutframe@[#1]<*>}%
}
\def\handoutframe@[#1]<#2>{% check for [opt]
  \@ifnextchar[{\handoutframe@@[#1]<#2>}{\handoutframe@@[#1]<#2>[]}%
}
\def\handoutframe@@[#1]<#2>[{%check if opt is [<def>]
  \@ifnextchar<{\handoutframe@@@[#1]<#2>[}{\handoutframe@do[#1]<#2>[<*>][}%
}
\def\handoutframe@@@[#1]<#2>[#3]{%read [<def>] and check for [opt]
  \@ifnextchar[{\handoutframe@do[#1]<#2>[{#3}]}{\handoutframe@do[#1]<#2>[{#3}][]}%
}
\def\handoutframe@do[#1]<#2>[#3][#4]#5{%
  \mode<#1>{%
%    grouping seems to be enough, but also possible to explicitly save
%    and restore current mode if necessary.
%    \edef\save@currentmode{\beamer@currentmode}
    \begingroup
    \def\beamer@currentmode{beamer}%
    % we've parsed all the arguments, so just call the inner function
    \beamer@@@againframe<#2>[{#3}][#4]{#5}%
    \endgroup
%    \edef\beamer@currentmode{\save@currentmode}%
  }%
}


%% 
%% \framescanonly 
%% 
% This command is similar to a <0> argument to \begin{frame} in that it
% suppresses the frame output.  But the frame is still scanned and so increment
% labels are available for use with \againframe or \handoutframe.

% Protect \mode from expansion as frame scans input.   If expanded then the
% effective mode would be frozen at first expansion, fouling \handoutframe's
% mode switch
\protected\def\beamincr@protected@mode{\mode}

\newcommand<>\framescanonly{%
  \if@allowscanonly%
  \beamincr@protected@mode#1{%
    \@ifundefined{AddToHookNext}%
      {\PackageWarning{beamincr}{\framescanonly is not supported in this LaTe\stringX version}}%
      {\AddToHookNext{shipout/before}{\DiscardShipoutBox}}%
  }%
  \fi
}

\newif\if@allowscanonly
\def\allowframescanonly#1{\ifnumgreater{#1}{0}{\@allowscanonlytrue}{\@allowscanonlyfalse}}
\@allowscanonlytrue
\def\@ifallowscanonlystate{\if@allowscanonly1\else0\fi}




%% 
%% incremental[do] environments
%%

% define env<> as a synonym for incrementalenv
\newcommand\@incremental@env@angles[1]{
  \csletcs{#1<>}{incremental#1}%
  \csletcs{end#1<>}{endincremental#1}%
}


%% user-facing incremental[do] environments

\newenvironment{incremental}{%
  \let\incremental@do\relax\Collect@Body\@incremental%
}{\ignorespacesafterend}
\@incremental@env@angles{}

\let\@endnext\relax
\newenvironment{incrementaldo}[1]{%
  \x@\long\x@\def\x@\incremental@do##1\@endnext{#1}\Collect@Body\@incremental%
}{\ignorespacesafterend}
\@incremental@env@angles{do}

\newenvironment{incrementaldocmd}[2][0]{%
  \x@\newcommand\x@\incremental@do\@firstofone{[#1]{#2}}\Collect@Body\@incremental%
}{\ignorespacesafterend}
\@incremental@env@angles{docmd}

\newenvironment{incrementaldodef}[2][]{%
  \x@\def\x@\incremental@do#1{#2}\Collect@Body\@incremental%
}{\ignorespacesafterend}
\@incremental@env@angles{dodef}

\newenvironment{incrementaldolongdef}[2][]{%
  \x@\long\x@\def\x@\incremental@do#1{#2}\Collect@Body\@incremental%
}{\ignorespacesafterend}
\@incremental@env@angles{dolongdef}

\newenvironment{incrementalitemize}{%
  \def\incremental@do{\incritem@next}%
  \def\incremental@do@prenext{\incritem@prenext}%
  \itemize\Collect@Body\@incremental%
}{\enditemize\ignorespacesafterend}
\@incremental@env@angles{itemize}

% field processing commands for incrementalitemize
\def\incritem@setspec[#1]{\def\incritem@spec{#1}}
\incritem@setspec[<.->&<~>]%
% multiple \x@s needed because of \newcommand option munging
\newcommand\incritem@next[1][\incritem@spec]{\x@\x@\x@\incritem@next@#1&&}
\def\incritem@next@#1&#2&{%
  \@ifempty{#2}{\incritem@next@@{#1}{\beamer@defaultospec}}{\incritem@next@@{#1}{#2}\@gobbleamp}}
\def\incritem@next@@#1#2#3\@endnext{%
  \let\saved@defaultospec\beamer@defaultospec\edef\beamer@defaultospec{#2}%
  \item#1#3%
  \let\beamer@defaultospec\saved@defaultospec}
\def\@gobbleamp#1&{}
\def\incritem@prenext{% look for itemize default spec
  \@ifnextchar[{\incritem@setspec}{}%
}


%% incremental[do] internals

\newcounter{next}

% default do commands do nothing
\let\incremental@do\relax
\let\incremental@do@prenext\relax
\let\incremental@do@star\relax

% for /next +/ label -- recurse to find first /next n/ > currentincr
\def\@nextplus#1{%
  \ifcsdef{beamincr@\frame@nameornumber @next #1}{%
    \ifnumless{\@currentincr}{\csuse{beamincr@\frame@nameornumber @next #1}}%
     {#1}{\@nextplus{\the\numexpr #1+1\relax}}%
  }{XX}%
}

% process the body of environment
\long\def\@incremental#1{%
  \setcounter{next}{0}%
  \incrlabelcode{next +}{\number\numexpr0\csuse{beamincr@\frame@nameornumber @next \@nextplus{0}}\relax}% create /next +/ label
  \@incremental@optspec#1\nextX% ungroup and terminate input
}

% environment option default spec
\newcommand\@incremental@optspec[1][<+->]{% defaults to <+->
  \edef\beamer@defaultospec{#1}%
  \@incremental@prenext%
}

% #1: field to first \next
% #2: remaining fields including terminal \next
\long\def\@incremental@prenext#1\next#2X{%
  \ifwhitespace{#1}%
    {\incrlabel{next \thenext}\stepcounter{next}\@incremental@next@chkstar#2X}% skip if nothing before first \next
    {\@incremental@next@spec{\incremental@do@prenext}{<.->}#1\next#2X}% default spec for pre-next field is <.->
}

% check for starred \next => no command
\newcommand\@incremental@next@chkstar{%
  \@ifstar%
    {\@incremental@next@spec{\incremental@do@star}{\beamer@defaultospec}}%
    {\@incremental@next@spec{\incremental@do}{\beamer@defaultospec}}%
}

% check for overlay spec within the field
% #1: command
% #2: default spec (may be a command, thus the \x@s)
\newcommand\@incremental@next@spec[2]{%
  \@ifnextchar<%input starts with overlay spec char
    {\@incremental@next@do{#1}}%
    {\x@\@incremental@next@do\x@{\x@#1\x@}#2}%
}
% #1: command
% #2: spec
% #3: field contents
% #4: remaining fields
\long\def\@incremental@next@do#1<#2>#3\next#4X{%
    \action<#2>{\incrlabel{next \thenext}#1#3\@endnext}%
    \@ifempty{#4}%
      {}% done
      {\stepcounter{next}\@incremental@next@chkstar#4X}%
}


%% 
%% create increment-aware alignment environments
%%

%% user-facing incremental align commands

%% \CreateIncrementalAlignEnvironment{name}[Nopts]{Nargs}[defaultspec][base environment]
% Create an incremental version of the named environment.  The new
% environment is accessible as either {incrementalname} or {name<>}.

\newcommand\CreateIncrementalAlignmentEnvironment[1]{%
  \@ifnextchar[{\@createincralign@opt{#1}}{\@createincralign@opt{#1}[0]}
}
\def\@createincralign@opt#1[#2]#3{%
  \@ifnextchar[{\@createincralign@opt@#1[#2]#3}{\@createincralign#1[#2]#3[<.->][#1]}%
}
\def\@createincralign@opt@#1[#2]#3[#4]{%
  \@ifnextchar[{\@createincralign#1[#2]#3[#4]}{\@createincralign#1[#2]#3[#4][#1]}%
}
  

% \setincrementalenvspec{name}{<spec1>&<spec2>...}
\def\setincrementalenvspec#1#2{%
  \gcsdef{@incralign@#1@defaultspec}{#2}%
}

% 
\newcommand\useincrementalenv[1]{%
  \ifcsdef{incremental#1}{%
    \csgdef{#1}{\csname incremental#1\endcsname}%
    \csgdef{end#1}{\csname endincremental#1\endcsname}%
  }{%
    \PackageError{beamincr}{Incremental #1 environment not created}{}%
  }
}

\newcommand\usenonincrementalenv[1]{%
  \ifcsdef{#1@orig}{%
    \csgdef{#1}{\csname #1@orig\endcsname}%
    \csgdef{end#1}{\csname end#1@orig\endcsname}%
  }% fail silently if not defined
}



%% Incremental alignment environment internals

% token register to collect the processed toks               
\newtoks\@incraligntoks

\def\@createincralign#1[#2]#3[#4][#5]{%
  \global\csletcs{#1@orig}{#5}%
  \global\csletcs{end#1@orig}{end#5}%
  \csdef{@incralign@#1@numopt}{#2}
  \csdef{@incralign@#1@numarg}{#3}
  \csdef{@incralign@#1@defaultspec}{#4}
  \newenvironment{incremental#1}{%
    \def\@incralign@this####1{\@incralign[#1]{####1}}%
    \collect@body\@incralign@this}{\ignorespacesafterend}%
  \@incremental@env@angles{#1}%
  % \csletcs{#1<>}{incremental#1}%
  % \csletcs{end#1<>}{endincremental#1}%
}

\def\@incralign[#1]#2{%
  \@incraligntoks={}% clear processed token list
  \debug@message{send to incralign@process: \unexpanded{#2}\\X^^J}%
  \@incralign@readargs{#1}{\csuse{@incralign@#1@numopt}}{\csuse{@incralign@#1@numarg}}#2\\X% process raw body token by token (\\ added to last line wiill be removed)
  \debug@message{send to #1@orig: \the\@incraligntoks^^J}%
  \def\beginenv{\begin{#1@orig}}% needed for \expandafter
  \x@\beginenv% pass expanded token list to base environment
    \the\@incraligntoks
  \end{#1@orig}%
}


% read any environment arguments and default spec
% #1 - environment name
% #2 - number of optional args left
% #3 - number of required args left
\def\@incralign@readargs#1#2#3{%
  \ifnumgreater{#2}{0}% any remaining optional args?
    {% check for one, if missing then no more optional args
      \@ifnextchar[{\@incralign@readoptarg{#1}{#2}{#3}}{\@incralign@readargs{#1}{0}{#3}}%
    }{%
        \ifnumgreater{#3}{0}% any remaining required args?
         {% read one
           \@incralign@readreqarg{#1}{#2}{#3}%
         }{% read the default spec and process the body
           \@ifnextchar[%
             {\@incralign@process@line}%
             {\x@\x@\x@\@incralign@process@line\x@\x@\x@[\csname @incralign@#1@defaultspec\endcsname]}%
         }
    }
}

\def\@incralign@readoptarg#1#2#3[#4]{%
  \iffirst<{#4}%
    {\ifnumgreater{#3}{0}%
      {\PackageError{beamincr}{Default spec appears before last reqd arg in #1<>}{}}%
      {\@incralign@readargs{#1}{0}{0}[#4]}%
    }{%
      \@incraligntoks=\x@{\the\@incraligntoks [#4]}%
      \@incralign@readargs{#1}{\numexpr #2 - 1\relax}{#3}%
    }%
}
\def\@incralign@readreqarg#1#2#3#4{%
  \iffirst[{#4}% looks like an opt arg
    {\PackageError{beamincr}{Too many optionals or default spec appears before last reqd arg in #1<>}{}}%
    {\@incraligntoks=\x@{\the\@incraligntoks {#4}}%
      \@incralign@readargs{#1}{#2}{\numexpr #3 - 1\relax}}%
}

%% main processing loop

% process line-by-line
% #1: increment spec
% #2: this line
% #3: remaining lines  
\def\@incralign@process@line[#1]#2\\#3X{%
   \@ifempty{#3}%
     {\@ifempty{#2}% 
         {}% there was nothing after last \\ in body -- done
         {\@incralign@process@field[#1]#1&X#2&\\#3X}%
     }{%
       \@incralign@process@field[#1]#1&X#2&\\#3X%
     }%
}

% process next field
% #1: full spec
% #2: spec to next &
% #3: remaining spec
% #4: remaning body
\def\@incralign@process@field[#1]#2&#3X#4X{%
  \@incralign@field@optspec[#1][#2][#3]#4X%
}

% check for overlay spec within the field
% #1: full spec
% #2: spec for this field
% #3: remaining spec
\def\@incralign@field@optspec[#1][#2][#3]{%
  \@ifnextchar<%input starts with overlay spec char
    {\@incralign@do@field[#1][#3][#2]}%
    {\@incralign@do@field[#1][#3][#2]#2}%
}

% process field teminated by &
% #1: full spec
% #2: remaining spec
% #3: default spec for this field
% #4: spec for this field
% #5: field contents
% #6: remaining line
% #7: remaining body
\def\@incralign@do@field[#1][#2][#3]<#4>#5&#6\\#7X{%
  \@incraligntoks=\x@{\the\@incraligntoks \def\beamer@defaultospec{#3}\action<#4>{#5}}%
  \@ifempty{#6}%
     {% reached last field on line
        \@ifempty{#7}{}% no more lines (so eol \\ was appended) - we're done
          {% else terminate line and check for optional arg
            \@incraligntoks=\x@{\the\@incraligntoks \\}%
            \@incralignbreak@checkopt#7X#1X% check for optional arg after \\
          }%
     }{% else more fields
        \@incraligntoks=\x@{\the\@incraligntoks &}%
        \@ifempty{#2}% reuse fullspec if we've exhausted the current one
          {\@incralign@process@field[#1]#1&X#6\\#7X}%
          {\@incralign@process@field[#1]#2X#6\\#7X}%
     }%
}

% check for optional arg after break
\def\@incralignbreak@checkopt{%
  \@ifnextchar[%
    {\@incralignbreak@getopt}%
    {\@incralignbreak@noopt}%
}

% no optional arg after break: just process
% #1: rest of body
% #2: full spec
\def\@incralignbreak@noopt#1X#2X{%
  \@incralign@process@line[#2]#1X%
}

% read optional arg after break
% #1: opt arg
% #2: rest of body
% #3: full spec
\def\@incralignbreak@getopt[#1]#2X#3X{%
  \@incraligntoks=\x@{\the\@incraligntoks [#1]}%
  \@incralign@process@line[#3]#2X%
}
      

%%
%% tagging actions for ams numbering environments
%%

\newcommand<>\eqnum{\only#1{\tag{\theequation}\refstepcounter{equation}}}
\newcommand<>\eqtag[1]{\only#2{\tag{#1}}}

%% 
%% create a few aligned environments by default
%%

\CreateIncrementalAlignmentEnvironment{align*}{0}[<+->&<.->&<.->&<.->&<.->&<.->&<.->&<.->]
%\CreateIncrementalAlignmentEnvironment{align}{0}[<+->&<.->&<.->&<.->&<.->&<.->&<.->&<.->]
%\CreateIncrementalAlignmentEnvironment{align}{0}[<+-|eqnum\at+->&<.->&<.->&<.->&<.->&<.->&<.->&<.->]
\CreateIncrementalAlignmentEnvironment{gather*}{0}[<+->]
%\CreateIncrementalAlignmentEnvironment{gather}{0}[<+->]
%\CreateIncrementalAlignmentEnvironment{gather}{0}[<+-|eqnum\at+->][gather*]
\CreateIncrementalAlignmentEnvironment{tabular}[1]{1}[<.->]
\CreateIncrementalAlignmentEnvironment{tabular*}[1]{2}[<.->]


%%
%% TikZ-dependent code -- only if tikz loaded
%%

% execute after preamble to allow tikz to be loaded after beamincr

\AtEndPreamble{\@ifpackageloaded{tikz}{

%% 
%% style for pointers in tikz
%%

\tikzset{pointer/.default=180}
\tikzset{pointer/.code={\@pointer@call#1;}}
\def\@pointer@call{\@ifnextchar[{\@pointer@call@}{\@pointer@call@[]}}
\def\@pointer@call@[#1]#2;{%
  \pgfkeysalso{append after command={(\tikzlastnode.center)--(\tikzlastnode.#2)
      node[pos=1,sloped,rotate=180,allow upside down,inner sep=0pt,every pointer,#1]{\@pointnow}}}%
}
\tikzset{every pointer/.style={}}
\tikzset{pointer sep/.style={xshift=#1*(-1)}}
\tikzset{pointer coordinate/.style={circle,inner sep=0pt,minimum size=0.1pt,node contents={}}}

\renewcommand\pointtonode[2][180]{\tikz[baseline]\node[anchor=base,text height=1.5ex,inner sep=0pt,pointer={#1}]{#2};}

%%
%% glerts
%%

% initialise a glert style
\def\makeglertstyle#1{%
  % initialise (empty) styles
  \defineglertstyle@store{#1}{picture}{active}[]{}\defineglertstyle@store{#1}{picture}{inactive}[]{}%
  \defineglertstyle@store{#1}{bbox}{active}[]{}\defineglertstyle@store{#1}{bbox}{inactive}[]{}%
  \defineglertstyle@store{#1}{node}{active}[]{}\defineglertstyle@store{#1}{node}{inactive}[]{}%
  \defineglertstyle@store{#1}{path}{active}[]{}\defineglertstyle@store{#1}{path}{inactive}[]{}%

  \tikzset{glert #1/.code={% install the glert style
      \if@resetoninstall\pgfkeys{/tikz/glert null}\@resetoninstallfalse\fi
      \pgfqkeys{/tikz}{glert picture inactive/.append style={glert #1 picture inactive={##1}}}%
      \pgfqkeys{/tikz}{glert picture active/.append style={glert #1 picture active={##1}}}%
      \pgfqkeys{/tikz}{glert bbox inactive/.append style={glert #1 bbox inactive={##1}}}%
      \pgfqkeys{/tikz}{glert bbox active/.append style={glert #1 bbox active={##1}}}%
      \pgfqkeys{/tikz}{glert node inactive/.append style={glert #1 node inactive={##1}}}%
      \pgfqkeys{/tikz}{glert node active/.append style={glert #1 node active={##1}}}%
      \pgfqkeys{/tikz}{glert path inactive/.append style={glert #1 path inactive={##1}}}%
      \pgfqkeys{/tikz}{glert path active/.append style={glert #1 path active={##1}}}%
  }}
  \pgfkeys{/glert/#1/.forward to=/tikz/glert #1}%
}

% set an object style #1 - glert, #2 - object, #3 - (in)active, [#4] default, #5 - style
\def\defineglertstyle#1#2#3{\@ifnextchar[{\defineglertstyle@store{#1}{#2}{#3}}{\defineglertstyle@store{#1}{#2}{#3}[]}}
\def\defineglertstyle@store#1#2#3[#4]#5{%
  \tikzset{glert #1 #2 #3/.style={#5}}%
  \ifblank{#4}{}{\tikzset{glert #1 #2 #3/.default={#4}}}%
}
% define an glert path (appended to node) #1 - glert; #2 - (in)active; #3 - path
\def\defineglertpath#1#2#3{%
  \defineglertstyle@store{#1}{node}{#2}[]{append after command={\pgfextra \path [overlay,glert?path] #3;\endpgfextra}}%
}

% the null glert style clears all the styles
\tikzset{glert null/.code={%
    \pgfqkeys{/tikz}{glert picture inactive/.style={}}%
    \pgfqkeys{/tikz}{glert picture active/.style={}}%
    \pgfqkeys{/tikz}{glert bbox inactive/.style={}}%
    \pgfqkeys{/tikz}{glert bbox active/.style={}}%
    \pgfqkeys{/tikz}{glert node inactive/.style={}}%
    \pgfqkeys{/tikz}{glert node active/.style={}}%
    \pgfqkeys{/tikz}{glert path inactive/.style={}}%
    \pgfqkeys{/tikz}{glert path active/.style={}}%
  }%
}
\pgfkeys{/glert/null/.forward to=/tikz/glert null}%

% parse [opt]angle:target values (for callouts, labels, etc)
\tikzset{
  glert angle parser/.code={\@glert@angle@parser@chkopt#1::X},
  glert angle/.initial=0,
  glert angle target/.initial={},
  glert angle pos/.initial=1,
  glert angle sep/.initial=0pt,
}
\def\@glert@angle@parser@chkopt{\@ifnextchar[{\@glert@angle@parser}{\@glert@angle@parser[]}}
\def\@glert@angle@parser[#1]#2:#3:#4X{%
  \@ifempty{#3}{\@ifempty{#4}%
    {\@glert@angle@parser@do[#1]{}{#2}}%  []foo
    {\@glert@angle@parser@do[#1]{#2}{}}%  []foo:
  }{\@glert@angle@parser@do[#1]{#2}{#3}}% []foo:bar
}
\def\@glert@angle@parser@do[#1]#2#3{\pgfkeysalso{
    glert angle options/.style={#1},
    glert angle=#2,
    glert angle target=#3,
    glert angle options/.get=\glertangleoptions,
    glert angle/.get=\glertangle,
    glert angle target/.get=\glertangletarget,
    % after parser called, 'pos' is overridden to set glert angle pos
    pos/.style={glert angle pos=##1,glert angle pos/.get=\glertanglepos},
    sep/.style={glert angle sep=##1,glert angle sep/.get=\glertanglesep},
}}
\def\glertangleplace{($(\glertnode.center)!\glertanglepos!(\glertnode.\glertangle) + (\glertangle:\glertanglesep)$)}

% define some basic glert styles
\makeglertstyle{alert}
  \defineglertstyle{alert}{node}{active}[red]{text=#1}
\makeglertstyle{box}
  \defineglertstyle{box}{node}{active}[red]{very thick,draw=#1}
\makeglertstyle{ellipse}
  \defineglertstyle{ellipse}{node}{inactive}{ellipse}
  \defineglertstyle{ellipse}{node}{active}[red]{ellipse,very thick,draw=#1}
\makeglertstyle{highlight}
  \defineglertstyle{highlight}{node}{active}[red]{fill opacity=0.2,text opacity=1,fill=#1}
\makeglertstyle{uline}
  \defineglertpath{uline}{active}{(\glertnode.south east) -- (\glertnode.south west)}
  \defineglertstyle{uline}{path}{active}{draw,red,very thick,#1}
\providecommand\tikzfading[1][]{}% do nothing if fading library not loaded
\tikzfading[name=spotlight,inner color=transparent!0, outer color=transparent!100]
\makeglertstyle{spotlight}
  \defineglertstyle{spotlight}{node}{active}[red!50]{ellipse,path fading=spotlight,fill=#1}
  \defineglertstyle{spotlight}{node}{inactive}{ellipse}
\makeglertstyle{connect}
  \defineglertpath{connect}{active}{(\glertnode) to #1}
  \defineglertstyle{connect}{path}{active}{draw,red,very thick,<->}
\tikzset{glert callout options/.style={rectangle callout, draw, pos=2.5, sep=0pt}}
\makeglertstyle{callout}
  \defineglertpath{callout}{active}{%
       node[glert angle parser={#1}, glert callout options,  glert angle options, at=\glertangleplace,
                callout absolute pointer=(\glertnode.\glertangle), node contents={\glertangletarget}]
     }

% trigger reset on installation of first glert style from options (but no reset if there aren't any styles)
\newif\if@resetoninstall
\pgfkeys{/glert/reset/.is if=@resetoninstall}
\pgfkeys{/glert/reset/.default=true}

% allow user to fine tune each object in \glert options
\pgfkeys{
  /glert/picture/.code={\pgfqkeys{/tikz}{glert picture active/.append style={#1}}},
  /glert/picture active/.code={\pgfqkeys{/tikz}{glert picture active/.append style={#1}}},
  /glert/picture inactive/.code={\pgfqkeys{/tikz}{glert picture inactive/.append style={#1}}},
%
  /glert/bbox/.code={\pgfqkeys{/tikz}{glert bbox active/.append style={#1}}},
  /glert/bbox active/.code={\pgfqkeys{/tikz}{glert bbox active/.append style={#1}}},
  /glert/bbox inactive/.code={\pgfqkeys{/tikz}{glert bbox inactive/.append style={#1}}},
%
  /glert/node/.code={\pgfqkeys{/tikz}{glert node active/.append style={#1}}},
  /glert/node active/.code={\pgfqkeys{/tikz}{glert node active/.append style={#1}}},
  /glert/node inactive/.code={\pgfqkeys{/tikz}{glert node inactive/.append style={#1}}},
%
  /glert/path/.code={\pgfqkeys{/tikz}{glert path active/.append style={#1}}},
  /glert/path active/.code={\pgfqkeys{/tikz}{glert path active/.append style={#1}}},
  /glert/path inactive/.code={\pgfqkeys{/tikz}{glert path inactive/.append style={#1}}},
}
% allow tikz keys in \glert options
\pgfkeys{/glert/.search also={/tikz}}

% (naming) glerts
\pgfkeys{
  /handlers/first char syntax=true,
  /handlers/first char syntax/the character (/.initial=\glert@name@node
}
\def\glert@name@node#1{\glert@name@node@#1}
\def\glert@name@node@(#1){\pgfkeysalso{node inactive={name={#1}}, node active={name={#1}}}}

%% user glert commands

% install a glert style
\newcommand{\useglert}[1]{\pgfqkeys{/glert}{reset,#1}}
\newcommand{\addglert}[1]{\pgfqkeys{/glert}{#1}} % no reset
\useglert{alert} % default is red text -- same as \alert

% set glerts
\newcommand\glert{\@ifstar{\@glert@star}{\@glert}}
\newenvironment<>{glertenv}{\@glertsactivate#1}{\ignorespacesafterend}% glertenv is the same as glertsenv
\newcommand<>\glerts[1]{{\@glertsactivate#2#1}}% group to prevent \glert* activation out of scope
\newenvironment<>{glertsenv}{\@glertsactivate#1}{\ignorespacesafterend}% environment groups for us

% glert[*] style for nodes
\tikzset{glert/.code={\@glert@nodeoption@spec#1X}}
\def\@glert@nodeoption@spec{\@ifnextchar<{\@glert@nodeoption}{\@glert@nodeoption<*>}}
\def\@glert@nodeoption<#1>#2X{\@glertsactivate<#1>\pgfkeysalso{glert*={#2}}}
\tikzset{glert*/.code={%
    \pgfqkeys{/glert}{reset,#1}%
    \pgfkeysalso{alias=@glertnode, alias=@glertbbox,  glert?node}%
}}
% can't work out how to put these in narrower scope!
\def\glertbbox{@glertbbox}%
\def\glertnode{@glertnode}%


% internals
\newcommand<>\@glert[2][]{{\@glertsactivate#3\@glert@star[#1]{#2}}} % group to restrict activation
\newcommand\@glert@star[2][]{%
  \ifmmode\@glert@set@node@mathcheck#1,X{#2}\else\@glert@set@node{}{}[#1]{#2}\fi
}

\def\@glert@set@node@mathcheck#1#2X#3{% [opt]{text} -- check first token in opt for mathstyle
  \ifdefequal{#1}{\displaystyle}{\@glert@set@node@math{\displaystyle}{[#2]{#3}}}{%
    \ifdefequal{#1}{\textstyle}{\@glert@set@node@math{\textstyle}{[#2]{#3}}}{%
      \ifdefequal{#1}{\scriptstyle}{\@glert@set@node@math{\scriptstyle}{[#2]{#3}}}{%
        \ifdefequal{#1}{\scriptscriptstyle}{\@glert@set@node@math{\scriptscriptstyle}{[#2]{#3}}}{%
          \mathpalette\@glert@set@node@math{[#1#2]{#3}}%
  }}}}%
}
\def\@glert@set@node@math#1#2{%mathstyle; args as {[opt]{text}}
  \@glert@set@node$#1#2%
}

% Ideally we would set the node contents in a box with appropriate mathstyle and then call tikz once.
% But \mathchoice (and therefore \mathpalette) sets all four arguments, and only chooses the
% appropriate one at the end of mmode.
% So the function called by \mathpalette has to complete the rendering (which it does 4 times).
% This is not efficient, but it seems necessary.
\newbox\@glerttext
\newbox\@glertphtm
\def\@glert@set@node#1#2[#3]#4{% (math)delim, style, opts, text
  \setbox\@glerttext=\hbox{#1#2#4#1}%
  \setbox\@glertphtm=\null%
  \wd\@glertphtm\wd\@glerttext\ht\@glertphtm\ht\@glerttext\dp\@glertphtm\dp\@glerttext%
  \begingroup% keep defs and style local
  \def\glerttextraw{#4}%
  \def\glerttextbox{\copy\@glerttext}%
  \def\glertphantom{\copy\@glertphtm}%
  \def\glerttextwidth{\wd\@glerttext}%
  \def\glerttextheight{\ht\@glerttext}%
  \def\glerttextdepth{\dp\@glerttext}%
  \def\glertbbox{@glertbbox}%
  \def\glertnode{@glertnode}%
  \pgfqkeys{/glert}{reset,#3}%
  \tikz[baseline,remember picture, glert?picture]{%
    \path[use as bounding box,glert?bbox] node[anchor=base,inner sep=0pt,glert?bbox,alias=@glertbbox]{\copy\@glertphtm};
    \path node[anchor=base,glert?node,alias=@glertnode]{\copy\@glerttext};
  }%
  \endgroup%
}

% activate: styles switch from inactive to active
\def\@glertsactivate<#1>{%
  \alt<handout:0|trans:0|article:0|#1>{%
    \tikzset{glert?picture/.style={glert picture active}}%
    \tikzset{glert?bbox/.style={glert bbox active}}%
    \tikzset{glert?node/.style={glert node active}}%
    \tikzset{glert?path/.style={glert path active}}%
  }{%
    \tikzset{glert?picture/.style={glert picture inactive}}%
    \tikzset{glert?bbox/.style={glert bbox inactive}}%
    \tikzset{glert?node/.style={glert node inactive}}%
    \tikzset{glert?path/.style={glert path inactive}}%
  }%
}
% start inactive
\@glertsactivate<0>


%% 
%% layers<> environment
%%

\newenvironment{incrementallayers}[1][]{%
  % check if the optional arg contains an overlay spec,
  \iffirst<{#1}{\def\beamer@defaultospec{#1}}{\tikzset{incremental layer/.append style={#1}}}%
  \x@\long\x@\def\x@\incremental@do##1\@endnext{\@incremental@layer@cmd{##1}}%
  \x@\long\x@\def\x@\incremental@do@star##1\@endnext{\@incremental@layer@cmd@star{##1}}%
  \Collect@Body\@incrementallayers%
}{\ignorespacesafterend}
\@incremental@env@angles{layers}

\tikzset{incremental layer/.style={}}
\tikzset{every layer/.style={}}
\tikzoption{layer@alignment}{\gdef\@incrementallayer@alignment{#1}}

\newcommand\@incrementallayers[1]{%
  \begin{tikzpicture}[%
      remember picture,
      t/.style={layer@alignment=t, anchor=north},
      c/.style={layer@alignment=c, anchor=center},
      b/.style={layer@alignment=b, anchor=south},
      every layer/.style={inner sep=0pt,t,incremental layer},
    ]
    \gdef\@incremental@layer@list{}
    \@incremental{#1}
  \end{tikzpicture}
}

\long\def\@incremental@layer@cmd#1{%
  \iffirst[{#1}{\@incremental@layer@cmd@opt#1X}{\@incremental@layer@cmd@opt[]#1X}
}
\long\def\@incremental@layer@cmd@opt[#1]#2X{%
  \xdef\@incremental@layer@list{\@incremental@layer@list (layer \thenext)}%
  \node(layer \thenext)[text width=\columnwidth,every layer, pointer=180,#1]{{#2}};
  % global options installed by every node style;  
}
\long\def\@incremental@layer@cmd@star#1{%
  \begin{scope}#1\end{scope}
}

\tikzset{
  % layer xy coordinates
  layer xy t/.style={shift=(#1.north west), x=(#1.north east), y=(#1.south west)},
  layer xy c/.style={shift=(#1.center), x=(#1.east), y=(#1.north)},
  layer xy b/.style={shift=(#1.south west), x=(#1.south east), y=(#1.north west)},
  layer xy/.default={current bounding box},
  layer xy/.code={\pgfkeysalso{layer xy \@incrementallayer@alignment=#1}},
  %
  % grids don't work with inverted xy coordinates dammit, so hack our own
  layer grid setup t/.style={min/.initial=0,max/.initial=1},
  layer grid setup b/.style={min/.initial=0,max/.initial=1},
  layer grid setup c/.style={min/.initial=-1,max/.initial=1},
  %
  layer grid minor/.style={spaced/.initial=0.1, help lines, @minor/.style={},
    minor/.style={@minor/.append style={##1}}, major/.style={}},
  layer grid major/.style={spaced/.initial=1, help lines, thick, @major/.style={},
    major/.style={@major/.append style={##1}}, minor/.style={}},
  %
  layer grid getparams/.style={min/.get=\@lgmin,max/.get=\@lgmax, spaced/.get=\@lgspaced,
    /utils/exec={\pgfmathsetmacro{\@lgincr}{\@lgmin+\@lgspaced}}},
  %
  layer grid install/.style={execute at begin scope={%
      \draw[layer grid minor, #1, @minor, layer grid getparams]
        \foreach \st in {\@lgmin,\@lgincr,...,\@lgmax} {(\@lgmin,\st) -- (\@lgmax,\st) (\st,\@lgmin) -- (\st,\@lgmax)};
      \draw[layer grid major, #1, @major, layer grid getparams]
        \foreach \st in {\@lgmin,\@lgincr,...,\@lgmax} {(\@lgmin,\st) -- (\@lgmax,\st) (\st,\@lgmin) -- (\st,\@lgmax)};
  }},
  layer grid/.default={},
  layer grid/.code={
    \pgfkeysalso{layer grid setup \@incrementallayer@alignment,
                 layer grid install={#1}}
  },
}


}} %% end tikz-dependent extensions

\catcode`X=11


% Local Variables:
% mode: latex
% eval: (set-fill-column 80)
% eval: (face-remap-add-relative 'default :family "Ubuntu Mono")
% End:
