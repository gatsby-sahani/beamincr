\documentclass[a4paper]{ltxdoc}

%% Fonts, etc.
%% Language and font encodings
\usepackage[english]{babel}

%% packages from beamer user guide
\usepackage{cmap}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{pifont}
\usepackage{makeidx}
\usepackage{pgf,xcolor}
\usepackage[pdfborder={0 0 0},bookmarksnumbered]{hyperref}
\usepackage[left=2.25cm,right=2.25cm,top=2.5cm,bottom=2.5cm,nohead]{geometry}
\usepackage{translator}

%% more packages
\usepackage{tabularx}
\usepackage{etoolbox}
\usepackage{tikz}
\def\TikZ{Ti\textit{k}Z}

%% beamer userguide macros
\input{beamerug-macros}

\def\beamincr{\texttt{beamincr}}

\def\OR{\kern3pt\vrule width0.4pt height1.9ex depth0.9ex\kern3pt}%$\Big|$}
\def\meta#1{$\langle${\rmfamily\itshape#1}$\rangle$}
\def\ometa#1{\opt{\meta{#1}}}
\def\sarg#1{\texttt{<\meta{#1}>}}
\def\osarg#1{\opt{\sarg{#1}}}
\def\optsarg#1{\opt{\tt[\sarg{#1}]}}
\def\ott#1{\opt{\texttt{#1}}}
\def\offset{\opt{\meta{offset}}}
\def\ooffset{\opt{\texttt{(\meta{offset})}}}
\def\textpipe{\char`\|}

\makeatletter
\def\sanitisecommand#1{\expandafter\sanitisecommand@\string#1\nil}
\def\sanitisecommand@#1#2\nil{%
  \if#1\@backslashchar\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi%
     {\textbackslash#2}{#1#2}%
}
\makeatother
\def\ttx#1{\texttt{#1}}
\def\ttc#1{\texttt{\sanitisecommand#1}}
\def\cmd#1{\cmdlink{\stripcommand#1}{\texttt{\sanitisecommand#1}}}


%% indexing

% make a list of commands 
\makeatletter
\def\listofcommands{%
  \list{}{\leftmargin=2em\itemindent-\leftmargin\def\makelabel##1{\hss##1}}%
  \itemsep1ex%
  \@starttoc{loc}%
  \item{}%
  \endlist%
}
\def\addtoloc#1#2{%
  \@ifempty{#2}%
    {\addtocontents{loc}{\protect\item{\texttt{#1}\hfill\thepage}}}%
    {\addtocontents{loc}{\protect\item{\texttt{#1}\hfill\thepage}\\#2}}%
}
\def\locsection#1{\addtocontents{loc}{\vskip2ex\protect\item{\large \bf #1}}}
\makeatother


\makeatletter
% create a pdfbookmark, and write a macro to aux to remember the hypertarget (with level)
\def\pdfbkmktarget#1#2{%
  \belowpdfbookmark{#1}{#2}%
  \csxdef{@bookmark@#2}{#2.\the\numexpr\Hy@currentbookmarklevel+1\relax}%
  \protected@write\@auxout{}{\string\csgdef{@bookmark@#2}{#2.\the\numexpr\Hy@currentbookmarklevel+1\relax}}%
}
% link to the bookmark hypertarget
\def\cmdlink#1#2{%cmd target; text
  \hyperlink{\csuse{@bookmark@#1}}{#2}%
}
% add command to list of commands 
\def\addcmdtoloc#1#2#3{% bookmark target; cmd header; description
  \addtoloc{\string\hyperlink{#1.\the\numexpr\Hy@currentbookmarklevel+1\relax}{#2}}{#3}%
}
\makeatother

\def\bkmkcmd#1#2@#3{%
  \pdfbkmktarget{\sanitisecommand#1}{\stripcommand#1}%
  \addcmdtoloc{\stripcommand#1}{\sanitisecommand#1#2}{#3}%
}

\def\bkmkcmdalt#1#2#3#4{%
  \pdfbkmktarget{#1}{#2}%
  \ifblank{#4}{}{\addcmdtoloc{#2}{\sanitisecommand#3}{#4}}%
}

\def\bkmkenv#1#2{%
  \pdfbkmktarget{\textbackslash begin\{#1\}\dots\textbackslash end\{#1\}}{#1}%
  \addcmdtoloc{#1}{\textbackslash begin\{#1\}\dots\textbackslash end\{#1\}}{#2}%
}


% modify command environment to add toc entry
\let\oldcommand\command
\def\command#1#2{\bkmkcmd#1@{#2}\oldcommand{#1}}

% alt commands (don't usually start with \, and/or may need a simplified bookmark and/or hypertarget name)
\makeatletter
\newenvironment{commandalt}{\@ifnextchar[{\@commandalt}{\@commandalt@noopt}}{\endcommand}
\def\@commandalt[#1]{\@ifnextchar[{\@commandalt@twoopt[#1]}{\@commandalt@twoopt[#1][#1]}}
%\def\@commandalt@noopt#1{\pdfindxcmdalt{#1}{#1}\oldcommand{#1}}
\def\@commandalt@twoopt[#1][#2]#3#4{%
  \bkmkcmdalt{#1}{#2}{#3}{#4}%
  \oldcommand{#3}%
}
\makeatother

% continue the command name (formatting from beamerug-macros)
\def\contcmd#1{\declare{\texttt{#1}}}

% misspelt in beamerug-macros
\let\oldextractenvironment\extractenvironement
\def\extractenvironement#1#2@{\bkmkenv{#1}{}\oldextractenvironment{#1}#2@}

% adapt the environment doc macro to provide environment contents
\def\envwithcontents#1#2{%
  \list{}{\leftmargin=2em\itemindent-\leftmargin\def\makelabel##1{\hss##1}}%
  \extractenvwithcontents#1@{#2}\par\topsep=0pt}
\def\endenvwithcontents{\endlist}
\def\extractenvwithcontents#1#2@#3{%
  \bkmkenv{#1}{}%
  \item{{\ttfamily\char`\\begin\char`\{\declare{#1}\char`\}}#2}%
    {\itemsep=0pt\parskip=0pt%
      {\itemindent=-1em #3}%
    \item{\ttfamily\char`\\end\char`\{\declare{#1}\char`\}}%
    }%
  \index{#1@\protect\texttt{#1} environment}%
  \index{Environments!#1@\protect\texttt{#1}}}


%% Maths
\usepackage{amssymb,amsmath}

%% Citations, refs, hyperlinks
\usepackage[capitalize]{cleveref}


%% Title

\title{Enhanced \beamer\ increments:\\
the \texttt{beamincr} package}
\author{Maneesh Sahani}
\date{\today}


%% Document

\begin{document}

\maketitle

\noindent
The \beamincr\ package extends and enhances the incremental overlay mechanisms
implemented in the \beamer\ class.  These include labels to refer to and
manipulate overlay steps, an extended action syntax, and new increment-aware
environments.

\section{Background: overlays and increments}

The basic \beamer\ display unit is the \texttt{frame}.  A
frame may be rendered step-by-step, in which case the individual
versions of the frame are called ``overlays'' or ``slides''.  We will
use these terms interchangeably.
%
\beamer\ allows you to place material on an arbitrary slide in a frame like this
\example
\begin{verbatim}
\begin{frame}
  text on slides 1 and up\\
  \onslide<2->
  text on slides 2 and up\\
  \onslide<3-4>{
  text only on slides 3 and 4\\
  } 
  \only<5>{text only on slide 5\\}
  more text on slides 2 and up\\
\end{frame}
\end{verbatim}
You can read about the differences between \myprintcommand{onslide}
and \myprintcommand{only}, and the many other overlay-sensitive
commands, in the \beamer\ user guide.  Note in particular the
difference between the argument form and the declaration forms of
\myprintcommand{onslide}.  \myprintcommand{only} only works with an
argument.

This explicit numbering approach becomes burdensome when you want many overlays.
You have to keep track of the numbers explicitly, and if you subsequently add a
step early in the sequence you need to re-number the rest.  Thus, \beamer\ also
provides an incremental overlay specification.  The following code will produce
the same effect as that above.  \example
\begin{verbatim}
\begin{frame}
  \resetincr % not standard BEAMER
  text on slides 1+\\
  \onslide<+->
  text on slides 2+\\
  \onslide<+-+(1)>{ % increments counter by 1, despite the two +s
  text only on slides 3-4\\
  } 
  \onslide<+>{} % increment counter by another
  \only<+>{text only on slide 5\\}
  more text on slides 2+\\
\end{frame}
\end{verbatim}
This form allows easy automation using default overlay specifications.  For
instance (from the \beamer\ user guide) \example
\begin{verbatim}
\begin{itemize}[<+-| alert@+>]
\item Apple
\item Peach
\item Plum
\item Orange
\end{itemize}
\end{verbatim}
There are important and sometimes not-entirely-intuitive differences between the
incremental and explicit numbering systems.  So we will refer to the steps
implied in this way as ``increments''.  They will mostly match slide numbers,
but not always, as this example shows: \example
\begin{verbatim}
\begin{frame}
  \resetincr % not standard BEAMER
  text on slide 1+\\
  \onslide<3>{text on slide 3}\\
  text on slide 1+\\
  \onslide<+->
  text on slide 2+\\
  \onslide<4->
  text on slide 4+\\ % increment number is still 2!
  \onslide<+->
  text on slide 3+\\
\end{frame}
\end{verbatim}
The increments have their own internal logic (specifically, their own internal
counter) which is not affected by any explicit slide specifications that may
appear between incremental calls.  It may make sense to think of the increment
number as being associated with \emph{where} in the source file the material
appears, rather than (necessarily) on \emph{which slide} it appears.

There are a couple of oddities with the way increments work that often trip up
first-time users.  There are also some extensions that would be nice, like the
ability to refer to a specific increment elsewhere in the frame.  These things
are certainly possible in stock \beamer, but take some digging into internals.
The tools here make things a bit easier.

As an aside, \beamer\ has another incremental overlay system based on the
\cmd\pause\ command.  This uses the same counter as increments (in fact, the
counter is called \texttt{beamerpauses}), but inteprets it slightly differently. This
difference is discussed in \cref{sec:internals}. As a result, the two sets of
specifications don't play very well together, at least from the viewpoint of
non-experts.  More on this below.  I strongly suggest avoiding
\cmd\pause\ entirely when using \beamincr.


\section{Setting increments}\label{sec:setting}
\locsection{Increment labels and references}

\begin{command}{\resetincr\oarg{incrnum}}%
  {set increment to 1 or \meta{incrnum}}%
  %
  Reset the increment number to 1, or to the value defined by the optional
  argument if given.  This doesn't directly affect the slide on which any
  following text appears, but it does alter the effect of subsequent
  \texttt{<+>} or \texttt{<.>} increments (as well as the
  \cmdlink{/!/}{/!/} reference discussed below).  This command may be
  useful to synchronise overlays in (say) two columns or between highlighted
  bullet points and highlighting in a figure.  \example
\begin{verbatim}
\begin{frame}
  \resetincr
  \begin{center}
    Two lists \onslide<+->{in sync}
  \end{center}
  \begin{columns}
    \begin{column}{.2\textwidth}
      \begin{itemize}[<+-| alert@+>]
      \item Apple \item Peach \item Plum \item Orange
      \end{itemize}
    \end{column}
    \begin{column}{.2\textwidth}
      \resetincr[2] % restart the increment counter to sync
      \begin{itemize}[<+-| alert@+>]
      \item green \item yellow \item purple \item orange
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}
\end{verbatim}
Any optional argument must either be a number or be an increment reference
enclosed in \texttt{//} (these are defined in \cref{sec:labels}).  It cannot
specify any sort of range, or be \texttt+ or \texttt., although \texttt{/./} and
things like \texttt{/.(2)/} are allowed.

It is useful to call \cmd\resetincr\ at the start of every increment-based slide
(as we have in the examples here).  This avoids some potentially confusing
behaviour that comes from the way the increment counter is implemented in
\beamer:
\example
\begin{verbatim}
\begin{frame}
  text on slides 1-\\
  \onslide<+->
  text still on slides 1-\\
  \onslide<+->
  text on slides 2-
  \resetincr\onslide<.->
  text on slides 1-\\
  \onslide<+->
  text on slides 2-
\end{frame}
\end{verbatim}
The first call to \ttc{\onslide<+->} doesn't advance the slide, unless it
has been preceded by a \cmd\resetincr\ (or another \ttc{\onslide<+->} or a \cmd\pause).
\end{command}

\begin{command}{\fromincr\sarg{incrnum}}%
  {{\tt \textbackslash resetincr[\meta{incrnum}] \textbackslash onslide<.->}}%
  This is shorthand for
\begin{verbatim}
\resetincr[incr]
\onslide<.->
\end{verbatim}
It can only be used as a declaration (not with an argument).  The restrictions
on \meta{incr} are the same as above.  
\end{command}

\section{Labelling and referring to increments}\label{sec:labels}

In complicated frames, it may be useful to name certain increments for reference
elsewhere.  For instance, one might want to change a figure at certain steps
while progressing through a list of bullet points.  Or one might want to
redisplay certain slides in the frame with \cmd\againframe\ or
\cmd\handoutframe\ (described below).

\begin{command}{\incrlabel\osarg{incrnum}\marg{label}}%
  {attach \meta{label} to current increment or to \meta{incrnum}}%
\end{command}
\vskip-3ex
\begin{commandalt}[\textbackslash incrlabel=//][incrlabelslash]%
  {\incrlabel\osarg{incrnum}\opt{\meta{=}}\texttt{/}\meta{label}\texttt{/}}%
  {attach \meta{label} to current increment or to \meta{incrnum}}%
%
  By default, this command attaches the current increment number to the label
  \meta{label}.  Once defined, the labelled increment can be recovered in
  (almost) any overlay spec using the constructs discussed below.  The
  \meta{label} can contain most characters, but should not start with any of the
  characters \texttt{.!=} or contain any of \texttt{()-~}.
  \hypertarget{label}{}%

  The \texttt= in the second form is optional, but if it is present then the
  \texttt{/\meta{label}/} may be separated from the \texttt= by additional
  material, which will be left in place.  The label must appear at the same
  grouping level as the \ttc{\incrlabel=} command and before the end of
  the current paragraph.  This is similar to the behaviour of the \texttt{=}
  action described in \cref{sec:actions:=}.

  If the optional \meta{incr} is provided, \meta{label} is set to its value.
  The restrictions on \meta{incr} are the same as for \cmd\resetincr: it
  can be a number or an increment specification.  This allows forms like
  \ttc{\incrlabel</.(2)/>{x}} to set \texttt x to the current increment +
  2.  See the discussion of increment specifications below.

  If \marg{label} starts with a number in parentheses (e.g. \texttt{(2)x}) then
  this number is added to the current increment, or to the value of \meta{incr},
  to obtain the label value.  Thus, the effect of the command above can also be
  achieved by \ttc{\incrlabel\{(2)x\}}.
\end{commandalt}

\begin{command}{\incrref \marg{incrref}}%
  {print increment value of \meta{incrref}}%
%
  This command returns the increment number defined by increment reference
  \meta{incrref} as described below.
\end{command}

\noindent
The general form of an increment reference is
\begin{commandalt}[<incrref>]{{ \meta{incrref}}: \meta{label}\ooffset}{}
%
  The label can be a string assigned by a call to \cmd\incrlabel, or the
  special label `\ttx.' which refers to the current increment (this is subtly
  different to the incremental overlay specification `\ttx.').  A further
  special label `\cmdlink{/!/}{!}'  is introduced in \cref{sec:actions:!}.  The
  \meta{offset}, if given, is added to the increment indicated by the label.  It
  can be negative.

  Increment references can be used as part of almost any overlay
  specification by enclosing them within slashes, e.g. \ttx{</foo(2)/>}.
\end{commandalt}
\example
\begin{verbatim}
\begin{frame}[label=twolists]
  \resetincr
  \begin{center}
    Two lists \onslide<+->{in sync}\\
    \onslide<+->{with more material\\}
    \onslide<+->{at the top}
  \end{center}
  \begin{columns}
    \begin{column}{.2\textwidth}
      \incrlabel{startlist}%
      \begin{itemize}[<+-| alert@+>]
      \item Apple \item Peach \incrlabel{halfway} \item Plum \item Orange
      \end{itemize}
    \end{column}
    \begin{column}{.2\textwidth}
      \resetincr[/startlist/]% keep in sync, even if we add extra topmatter
      \begin{itemize}[<+-| alert@+>]
      \item green \item yellow \item purple \item orange
      \end{itemize}
    \end{column}
  \end{columns}
  \vfill
  \onslide<+->
  The final increment is \incrref{.}. 
  \incrlabel{end}
\end{frame}
\end{verbatim}
%
\hypertarget{incrnum}{}%
Note that of commands discussed here, \cmd\incrref\ expects an \meta{incrref}
specification (i.e., \meta{label}\ooffset), while \cmd\resetincr,
\cmd\fromincr\ and \cmd\incrlabel\ expect an \meta{incrnum} specification that
might be an \meta{incrref} in \ttx{//} (i.e., \ttx{/\meta{label}\ooffset/}) or
just a number.  Standard overlay-aware commands should all accept overlay
specifications that include \meta{incrnum}s.

One \beamer\ command (slightly patched in this package) with which named
increments are particularly useful is \cmd\againframe.  So \example
\begin{verbatim}
  \againframe<1,/halfway/,/end(-1)/-/end/>{twolists}
\end{verbatim}
provides an abbreviated tour of the lists.  Increment labels are associated with
the label of the enclosing frame, and so the same names can safely be reused
across multiple named frames.

There is also a similar new command called \cmd\handoutframe\ to render more
than one overlay from a frame in \ttx{handout} or similar modes that otherwise
just show a single slide with all the overlays collapsed.  See \cref{sec:again}.

\section{Enhanced overlay action specifications}\label{sec:actions}

This section discusses further extensions to the overlay specification syntax,
and its interaction with increments and increment labels.
%
Many of these extensions are only valid in a context that supports
\beamer\ actions.  According to the user guide, these are \ttc\action,
\ttc\item, the \ttx{actionenv} environment and block environments like
\ttx{block} and \ttx{theorem}.  This package adds the fields of incremental
(\cref{sec:envs}) and incremental alignment (\cref{sec:align}) environments to
this list.  In the absence of any action specifications, \ttc\action\ acts like
\ttc\uncover.


\subsection{Setting increments in overlay action specifications} \label{sec:actions:!}

\begin{commandalt}[<resetincr@>]{{<resetincr@}\meta{incrnum}\contcmd{>}}{}
\end{commandalt}
\vskip-3ex
\begin{commandalt}[<!\meta{incrnum}>][<!incrnum>]{{<}\ott{\meta{incrnum}-}\contcmd!\meta{incrnum}\ott{-\meta{incrnum}}\contcmd{>}}{}
The current increment number can be reset using either the explicit
\ttx{resetincr@\meta{incrnum}} action, or an implicit \ttx{<!\meta{incrnum}>}
specification.  The \ttx!\meta{incrnum} may appear at either the start or end of
a (possibly open) range, so no more than one of the optional \ometa{incrnum}s
should be present.  To set to an intermediate value, use a specification like
\ttx{<1-4,!3>}.
%
\example
\begin{verbatim}
  \action<3-|resetincr@3>{body}
  \action<!3->{body}
\end{verbatim}
The increment number can be a label, with optional offset:
\begin{verbatim}
  \incrlabel<2>{x}
  \resetincr
  \action</x/->{body on 2+}
  \onslide<.->{this on 1+}
  \action<!/x(2)/->{body on 4+}
  \onslide<+->{this on 5+}
\end{verbatim}
The forms \ttx{<!+>} and \ttx{<!.>} aren't supported (and wouldn't be useful:
\ttx{<+>} already advances the increment, while \ttx{<!.>} would set it to its
current value).  However \ttx{<!/.(\meta{offset})/>} (note the \ttx/ label
notation) can be used to advance the increment counter by multiple (or negative)
steps.

The reset takes effect after the overlay specification has been interpreted and
before the body is set.  So any \ttx+ or \ttx. references will be relative to
the increment in effect \emph{before} the \ttc\action.
%
\pdfbkmktarget{}{/!/}%
%
However, the special increment label \ttx{/!/} can be used to access the most
recent reset (but note the discussion of evaluation order below).
%
\example
\begin{verbatim}
  \resetincr
  \action<!/.(2)/-|alert@.>{alerts too early}
  \action<!/.(2)/->{\alert<.>{alerts when uncovered}}
  \action<!/.(2)/-|alert@/!/>{alerts when uncovered}
\end{verbatim}

It is possible to issue multiple implicit and explicit resetincr action commands
in one overlay spec (including at both limits of a \meta{range}).  The increment
number in effect after the \meta{action spec} will be determined by the first
explicit \ttx{resetincr@} action, or if there are none, the first implicit
\ttx{!\meta{incrnum}} specification.

If any actions within the same \meta{action spec} depend on a \ttx{/!/}
increment reference, then this value will be determined by the \emph{following}
\ttx{resetincr@} value, or if there are none, the \emph{first}
\ttx!\meta{incrnum}, or if there are none, the most recent increment reset (by a
\cmd\resetincr\ command or an action).  If there are no preceding resets in the
frame, then \ttx{/!/} (along with any offset) evaluates to 0.  See the
discussion of \cmd\allowundefinedincrlabels\ for more on 0-valued references,
but note that this behaviour for \ttx{/!/} is independent of the
\cmd\allowundefinedincrlabels\ state.
%
\example
\begin{verbatim}
  \resetincr
  \action<1-5|resetincr@3|alert@/!/>{alerts on slide 1\\}
  \action<1-5|alert@/!/>{alerts on slide 3\\}
  \resetincr
  \action<1-5|alert@/!/|resetincr@3>{alerts on slide 3\\}
  \action<1-!5|point@/!/|resetincr@4|alert@/!/>{points on slide 4; alerts on slide 5\\}
\end{verbatim}

This ordering behaviour can be understood from the following two facts:
\beamer\ applies actions in the reverse order to that in which they appear in
the specification, and \beamincr\ maps \ttx{!\meta{incrnum}} specifications to
explicit actions at the \emph{end} of the \meta{action spec}, preserving their
order.

Actions must be used with argument text (usually enclosed in braces) or as
environments.  There is no equivalent to the declaration form of \ttc\onslide.
Note, however, that \cmd\fromincr\ (\cref{sec:setting}) implements an
\ttc\onslide\ declaration while also setting the current increment.  See also
the \cmdlink{incremental}{\tt incremental} environment
(\cref{sec:envs:incremental}).
\end{commandalt}

\subsection{Assigning labels from overlay action specifications} \label{sec:actions:=}

\begin{commandalt}[<=>/label/]{{<$\cdots$\textpipe=}\ooffset\contcmd{\textpipe$\cdots$>}%
    \ttx{\{\dots /\ooffset\meta{label}/ \dots\}}}{} This syntax can be used
  to assign a label using an action specification.  The name of the label to be
  assigned must be enclosed in \ttx{//}s within the \emph{argument} of the
  \ttc\action\ (or \ttc\item\ or \ttc\next\ or alignment field
  \dots)\footnote{\beamer\ actions don't make it possible to pass a text
  argument to the handler.}  The label is assigned to the increment number after
  any \ttx{+} or \ttx{!} actions have been interpreted, as though it was
  called with \cmd\incrlabel\ in place.  Thus in this code \example
\begin{verbatim}
  \resetincr[3]
  \action<!/.(2)/>{\incrlabel{x}action text}
  \resetincr[3]
  \action<!/.(2)/|=>{/x/action text}
  \resetincr[3]
  \action<!/.(3)/>{\incrlabel</.(-1)/>{x}action text}
  \resetincr[3]
  \action<!/.(3)/|=(-1)>{/x/action text}
  \resetincr[3]
  \action<!/.(3)/|=>{/(-1)x/action text}
\end{verbatim}
the first two action calls set the label \ttx{x} to 5.  The last three
illustrate the use of assignment offsets: if \ttx{=} is followed by a number
in parentheses, this is treated as an offset to add to the current increment at
assignment, in the same way as indicated by the optional
\ttx{<\meta{incrnum}>} argument to \cmd\incrlabel.  The same effect can
be achieved by placing the offset before the label name within the enclosing
\ttx{//}.

If no \ttx{/\meta{label}/} is found or if \meta{label} is empty, the action
tries to do nothing quietly.  This makes it possible to use an \ttx{=} in a
default spec, while only assigning a label on selected steps.  However, this
behaviour comes with warnings, and should be used with caution.  First, because
of the way \beamer's internals work, it is not currently possible to omit the
\ttx{//} in an \ttc\item, although the label can be empty (omission is fine in
the fields of an incremental or incremental alignment environment).  Second, if
there happens to be one more or more \ttx{/} characters in the argument to the
action, the text between them (or from a single \ttx{/} to the end) will be
interpreted as a label, unless they appear in a group within the argument, or an
explicit \ttx{//} pair appears first.  You have been warned!
\end{commandalt}


\subsection{Extending default overlay or action specifications} \label{sec:actions:~}
    
\begin{commandalt}[<\textasciitilde>][tilde]{{<$\cdots$\textpipe\textasciitilde\textpipe$\cdots$>}}{}
Ordinarily, explicit overlay or action specifications override any defaults that
might apply.  It may sometimes be convenient to instead extend the default.  The
|~| spec can be used to add the current default spec fields into an explicit
overlay specification.  In this form, the \ttx\textasciitilde\ may be proceeded
by, say, a mode specification, but must not be followed by any text with the
specification field (i.e., to the next \ttx\textpipe\ or \ttx>).
%
\example
\begin{verbatim}
  \begin{itemize}[<+-| alert@+|=>]
  \item/ap/ Apple \item/pe/ Peach \item/pl/ Plum \item/or/ Orange
  \end{itemize}
  \begin{itemize}[<alert@/!/>]
  \item<!/pe/-|~> yellow \item<!/or/-|~> orange \item<!/ap/-|~>green \item<!/pl/-|~> purple
  \end{itemize}
\end{verbatim}
Within incremental alignment environments (\cref{sec:align}), a |~| will
incorporate the field-specific default.

This extension is available is any overlay specification.
\end{commandalt}

\begin{commandalt}[<defaultspec@>]{{<defaultspec@}\meta{range}\contcmd{>}}{}

  Action to set the default specification for overlay references within the
  action argument.  The \meta{range} may be any valid specification for a set of
  slides (such as \ttx{1}, \ttx{+-} or \ttx{!/foo/-/bar/}).  The range is
  evaluated within the context of the \ttx{defaultspec@} specification, yielding
  specific slide numbers.  Thus, any labels (including \ttx{/./} and \ttx{/!/})
  or \ttx+ or \ttx. symbols will be replaced by their current values.  For
  example, in
\begin{verbatim}
  \resetincr[3]
  \action<+-|defaultspec@+>{\only<~>{only body} other stuff}
\end{verbatim}
  the specification to \ttc\only\ is set to \ttx{<4>}, not to
  \ttx{<+>}, which would evaluate to slide 5 in context.  See also the
  \ttx\textasciitilde\ action below.
\end{commandalt}

\begin{commandalt}[<\textasciitilde range>][tilde range]{{<\textasciitilde}\meta{range}\contcmd{\textpipe$\cdots$>}}{}

  This is equivalent to \ttx{<\meta{range}\textpipe
    defaultspec@\meta{range}\textpipe$\cdots$>}.  That is, it executes the
  calling action on \meta{range} (using normal overlay evaluation rules) and
  also sets the default specification within the action argument to the
  evaluated range.
  %
  This extension only works in an action specification context.  As the body of
  the argument will usually only be visible for the specified range anyway, the
  specification is most useful to control side effects.
  \example
\begin{verbatim}
  \resetincr
  \setcounter{displayed}{0}
  \begin{itemize}[<+->]
  \item \only<~>{\stepcounter{displayed}} % \only<+-> adds another increment
  \item<~+-> \only<~>{\stepcounter{displayed}} % \only<4-> does not
  \item<~~> \only<~>{\stepcounter{displayed}} % \only<5-> does not
  \end{itemize}
\end{verbatim}
    In the example, the \ttc\only\ commands are used to advance the counter on
    slides where the \ttc\item s are visible.  In both cases the overlay
    specification to \ttc\only\ is a copy of the surrounding default
    specification.  For the first one, this is \ttx{<+->}.  For the second, it
    is \ttx{<+->} \emph{evaluated} within the \ttc\item\ call, giving
    \ttx{<3->}.  The final case expands the second |~| to the default \ttx{+-},
    which becomes the increment specification for the item, and then sets the
    default within the item to its value, which is \ttx{5-}.
\end{commandalt}


\subsection{Advanced references: using labels defined later} \label{sec:actions:advanced}

\begin{command}{\allowundefinedincrlabels\oarg{flag}}%
  {control whether undefined labels generate errors or  evaluate to 0}
  %
  If called alone, or with option \meta{\opt{flag}} > 0, tells \LaTeX\ not to
  generate an error when encountering an undefined increment label.  References
  to such labels instead evaluate to 0, and any offset in the reference is
  ignored.  If \meta{\opt{flag}}=0, the default error-generating behaviour is
  restored.
\end{command}
If a referenced label is defined later in the same frame, then it will take on
that later-defined value on subsequent slides of the frame.  Thus, in effect,
this option makes it possible to refer to increment labels before they are
defined.  (Although material intended to be set on slide 1 cannot depend on such
advance references.)

If the label is used as part of an open range then it may be necessary to use a
special syntax in which the range indicator is placed \emph{within} the
\ttx{/ /} enclosing the label.  If the label is undefined (and so 0), this
syntax sets the other limit of the range to 0 as well.  \example
\begin{verbatim}
  % /foo/ is not defined on first evaluation
  \onslide</foo/->{spec expands to <0->, so text appears on all slides}
  \onslide</foo-/>{spec expands to <0-0>, so text is suppressed}
  \incrlabel<2>{foo} % on later evaluations, both specs will expand to <2->
\end{verbatim}
If the range is closed with an explicit numerical or (defined) label upper
limit, then there is no current way to suppress early expansion.  However forms
like \ttx{/foo/-/foo(2)/} will evaluate to \ttx{0-0} as offsets are
ignored for undefined labels.

Many problems with advanced references (including range expansion and the
rendering of first-slide material) can be resolved by use of
\cmd\framescanonly\ and \cmd\againframe\ (\cref{sec:again}).

An \cmd\allowundefinedincrlabels\ command also makes it possible to
\emph{set} the current increment to an (initially) undefined label value using
\cmd\resetincr, \cmd\fromincr, or \ttx{<!/label/>}, thereby
setting the current increment to 0.  Text set on that increment will not appear
until the label is defined.  However, any subsequent \ttx{<+>} specs will
still advance the increment number, which may not be desired.  This behaviour
can be avoided by using the form \ttx{<!/.(1)/>} instead of \ttx{<+>}.
The current increment label \ttx{/./} is treated in the same way as an
undefined one when the increment is 0, and so the offset is ignored.  \example
\begin{verbatim}
\resetincr{/foo/} % no list items appear until /foo/ is defined
\begin{itemize}<!/.(1)-/|alert@/!/>
\item foo
\item bar
...
\end{itemize}
\end{verbatim}
If an initially undefined label is used to set the increment counter early in
the frame, then increment labels that are defined later in the frame may change
value once that first label is defined.  This can be used for powerful effects,
in which overlays in two different sections of the frame each depend on
increments from the other.  However, if the definition label used in the early
reference is itself altered by the change in that early evaluation, then there
is a risk of creating an infinite loop.
\example
\begin{verbatim}
  \begin{itemize}[<alert@/!/>]
  \item<!/./-     |~|=(1)>/ping/ Apple  % 1- (!/./ ensures alert occurs on same slide)
  \item<!/pong-/  |~> Peach             % 4-
  \item<!/.(1)-/  |~|=>/ping2/ Plum     % 5-
  \item<!/pong2-/ |~> Orange            % 8-
  \end{itemize}
  
  \begin{itemize}[<alert@/!/>]
  \item<!/ping-/  |~> green             % 2-
  \item<!/.(1)-/  |~|=(1)>/pong/ yellow % 3-
  \item<!/ping2-/ |~> purple            % 6-
  \item<!/.(1)-/  |~|=(1)>/pong2/orange % 7-
  \end{itemize}
\end{verbatim}



\section{Incremental environments}\label{sec:envs}

The \beamincr\ package provides some new increment-aware environments.  These
are described in the present section.  It also makes it possible to use
increment specifications within alignment environments such as \ttx{tabular} or
\AmSTeX\ \ttx{align}; these are discussed in \cref{sec:align}.

Each new environment is accessible under two, otherwise equivalent, names.  A
common base name is either preceded by the word \ttx{incremental} or followed
by the symbols \ttx{<>}.  The environments in this section separate material
into overlays using the token \ttc\next\ or \ttc{\next*}.  Many will
also apply an implicit or explicitly defined command to that material when
\ttc\next\ is used, but omit the command for \ttc{\next*}.

\subsection{Standard incremental environments}\label{sec:envs:incremental}
\locsection{Incremental environments}
\tracingmacros1
\begin{envwithcontents}{{incremental}\optsarg{default specification}}
  {\item \hskip1em \osarg{pre-next specification} \opt{\meta{pre-next contents}}
    \item \ttx{\string\next}\osarg{next specification}
    \item \hskip1em \meta{next contents}
    \item \ttx{\string\next}\osarg{next specification}
    \item \hskip1em \meta{next contents}
    \item \hskip2em $\vdots$
  }
  This environment can be thought of as an increment-aware \ttx{itemize}
  without the list formatting.  This makes it suitable for incremental control
  of a wider range of types of code, such as \TikZ\ drawing commands.
%
  The keyword \ttc\next\ within the environment acts like
  \ttc\item\ in terms of incremental processing: the \meta{next contents}
  are set within an \ttc\action\ command.  Each \ttc\next\ call can
  be followed by an optional \osarg{next specification}, which is applied to the
  \meta{next contents}.  If the specification is omitted, then the environment
  \ometa{default specification} is applied.  If no \meta{default
    specification} was given in the environment, then the default is inherited
  from the frame or container default.  This is ordinarily \ttx{<*>}.

  Unlike in \ttx{itemize} environments, code can also appear before the first
  \ttc\next.  If any does, it is treated just like \meta{next contents}: it is
  processed with the action specification given by \osarg{pre-next specification}
  if present, or else the default specification.  On the other hand, if nothing
  but whitespace appears between the opening of the environment---or the
  optional default overlay spec---and the first \ttc\next, then no action is
  applied.  This avoids side effects from, e.g., \ttx{<+>} specifications in
  the default.  (The same does not apply to later empty \meta{next contents}:
  these are always set within action commands, triggering any side effects.)

  A counter called \ttx{next} is set to 0 in the pre-next field and then
  advanced at every \ttc\next.  \example
\begin{verbatim}
\resetincr
\begin{incremental}[<+->]
  <.-> this text on slide 1;
\next
  on slide 2;
\next<!/.(2)/->
  on slide 4, but after only \thenext\ next commands.
\end{incremental}
\end{verbatim}
\end{envwithcontents}
\begin{environment}{{<>}\optsarg{default specification}}
  This is a synonym for |\begin{incremental} ... \end{incremental}|.
\end{environment}
%
The following environments apply a specified command to each overlay contents.

\begin{envwithcontents}{{incrementaldo}
    \marg{command definition}\optsarg{default specification}}
  {\item \hskip1em \osarg{pre-next specification} \opt{\meta{pre-next contents}}
    \item \ttx{\string\next}\osarg{next specification}
    \item \hskip1em \meta{next contents}
    \item \ttx{\string\next}\osarg{next specification}
    \item \hskip1em \meta{next contents}
    \item \hskip2em $\vdots$
  }

  This version treats each \meta{next contents} as the argument to a command.
  The command takes a single argument and is defined by \meta{command
    definition} in the same way as in \ttc\newcommand.  As the command
  evaluation happens deep within the bowels of \beamer\ processing, the single
  argument generally needs to be accessed as |####1|, \emph{unless} the
  enclosing frame is declared to be \ttx{fragile} (in the frame options), in
  which case it is just |#1|.

  The do command can be avoided for specific fields by using \ttc{\next*} in
  place of \ttc\next.  Contents following \ttc{\next*} are set in the same way
  as in a plain \ttx{incremental} environment.

  Any non-empty \meta{pre-next contents} is always processed without the do
  command.
  
\end{envwithcontents}
\begin{environment}{{do<>}\marg{command definition}\optsarg{default specification}}
  This is a synonym for |\begin{incrementaldo} ... \end{incrementaldo}|.
\end{environment}


\begin{envwithcontents}{{incrementaldocmd}
    \oarg{num args}\marg{code}\optsarg{default specification}}
  {\item \hskip1em \osarg{pre-next specification} \opt{\meta{pre-next contents}}
    \item \ttx{\string\next}\osarg{next specification}
    \item \hskip1em \meta{next contents}
    \item \ttx{\string\next}\osarg{next specification}
    \item \hskip1em \meta{next contents}
    \item \hskip2em $\vdots$
  }

   This version inserts \meta{code} (comprising arbitrary \LaTeX\ commands)
   after each \ttc\next\ and before \meta{next contents}.  If \meta{code} is (or
   ends with) a command that takes one or more arguments, these will be read
   from \meta{next contents}.  Braces may be needed within that text to
   delineate the arguments.

   If the optional \opt{\meta{num args}} is non-zero, then this number of
   arguments is read from the text following \ttc\next\ and can be accessed
   using argument parameters (almost) as in \ttc\newcommand.  As the command
   evaluation happens deep within the bowels of \beamer\ processing, the
   parameter numbers must be protected with four |####| symbols, \emph{unless}
   the frame is declared to be \ttx{fragile} (in the frame options) in which
   case a single |#| works.

  Execution of the \meta{code} can be avoided for specific fields by using
  \ttc{\next*} in place of \ttc\next.  Contents following \ttc{\next*} are set
  in the same way as in a plain \ttx{incremental} environment.

  Any non-empty \meta{pre-next contents} is always processed without
  \meta{code}.

  \example
\begin{verbatim}
\tikz[every node/.style={above,allow upside down,midway,sloped}]{
  \begin{incrementaldocmd}[1]{\draw ({72*\thenext-72}:10ex)--(72*\thenext:10ex) node {#1};}
                          [<+-|alert@+|=>]
    \next/one/   {one}
    \next/two/   {two}
    \next/three/ {three (\thenext/\theincrement)}
    \next/four/  {four}
    \next/five/  {five}
    \next*/done/ \draw (0:5ex) \foreach \t in {1,...,5}{ -- (\t*72:5ex)};
                 \node [anchor=center] {done!};
  \end{incrementaldocmd}}
\end{verbatim}
\end{envwithcontents}
\begin{environment}{{docmd<>}
    \oarg{num args}\marg{code}\optsarg{default specification}}
  This is a synonym for |\begin{incrementaldocmd} ... \end{incrementaldocmd}|.
\end{environment}


\begin{envwithcontents}{{incrementaldodef}
    \oarg{parameter spec}\marg{code}\optsarg{default specification}}
  {\item \hskip1em \osarg{pre-next specification} \opt{\meta{pre-next contents}}
    \item \ttx{\string\next}\osarg{next specification}
    \item \hskip1em \meta{next contents}
    \item \ttx{\string\next}\osarg{next specification}
    \item \hskip1em \meta{next contents}
    \item \hskip2em $\vdots$
  }
  This is similar to the \ttx{incrementaldocmd} environment, but allows 
  arguments to be specified using the flexible format of \ttc\def.  Parameter
  numbers must be escaped with four |#|s in both specification and code, unless
  the frame is declared \ttx{fragile}.  Code execution can be skipped using \ttc{\next*}
  and is always skipped for any \meta{pre-next contents}.
\end{envwithcontents}
\begin{environment}{{dodef<>}
    \oarg{parameter spec}\marg{code}\optsarg{default specification}}
  This is a synonym for |\begin{incrementaldodef} ... \end{incrementaldodef}|.
\end{environment}

\begin{environment}{{incrementaldolongdef}
    \oarg{parameter spec}\marg{code}\optsarg{default specification}}

  This form allows paragraph breaks within \meta{next contents}, but is
  otherwise the same as \ttc{\begin\{incrementaldodef\}} \ttx{...}
  \ttc{\end\{incrementaldodef\}},
\end{environment}
\begin{environment}{{dolongdef<>}
    \oarg{parameter spec}\marg{code}\optsarg{default specification}}
  This is a synonym for |\begin{incrementaldolongdef} ... \end{incrementaldolongdef}|.
\end{environment}


\subsection{\TikZ-based incremental environments}\label{sec:envs:tikz}

The following environments use \TikZ\ picture commands to create their effects.
They will only be defined if \TikZ\ is also loaded in the document preamble.

\begin{envwithcontents}{{incrementallayers}
    \oarg{node options}\optsarg{default specification}}
  {\item \hskip1em \osarg{pre-next specification} \opt{\meta{pre-next contents}}
    \item \ttx{\string\next}\osarg{next specification}\oarg{next node options}
    \item \hskip1em \meta{next contents}
    \item \ttx{\string\next}\osarg{next specification}\oarg{next node options}
    \item \hskip1em \meta{next contents}
    \item \hskip2em $\vdots$
  }

  Set \meta{next contents} within overlayed \TikZ\ nodes.  This may have the
  effect of later text appearing to be layered on top of earlier material.  If
  the specifications place material on mutually exclusive increments (e.g. with
  \ttx{<+>}) then this has a similar effect to \beamer's \ttx{overprint}
  environment.  In particular, the region occupied by the environment will
  correspond to the largest of the nodes.  However, this behaviour can be
  subverted by use of \ttc\only\ or similar commands within the \meta{next
    contents}, or \ttx{only@} actions in \meta{next specification}s; these
  should be used with care.

  By default, nodes are set with |text width = \columnwidth, inner sep=0pt| so
  that the text fills the width of the current frame or column or minipage.
  They are aligned at their top borders.  These defaults can be overridden, and
  arbitrary \TikZ\ options provided to the nodes, in one of three ways: by setting
  options in the \ttx{incremental layer} \TikZ\ style, by placing them in the optional
  \meta{node options} argument to the environment, or by placing them in the
  optional \meta{next node options} after a \ttc\next, (and after any \meta{next
    specification}).

  Three shorthand node alignment keys are available: \ttx t aligns the nodes at
  their top edges (the default); \ttx{b} at their bottom edges and \ttx{c} at their
  centres.

  The entire environment is set within a single \ttx{tikzpicture}.  Any
  \meta{pre-next contents} and the contents of any \ttc{\next*} are passed
  directly to \TikZ.  The default origin of the coordinate system is the
  \ttx{north}, \ttx{center} or \ttx{south} anchor points of the layer nodes for
  \ttx t, \ttx c and \ttx b alignment respectively.  The nodes themselves are accessible
  under the names \ttx{(layer \meta{n})}, where \meta{n} is the corresponding
  value of the |next| counter.
  %
  The \TikZ\ option |fit layers| can be given to a node to surround all the layers
  defined so far in the |incrementallayers| environment (see the \TikZ\ fit
  library).

  There is also a new environment called |boundinglayerscope| which creates a
  \TikZ\ |scope| with the following additions.  A node called |(bounding layer)|
  is created to (tightly) fit the layers defined so far, and the |xy| coordinate
  system in the scope is redefined according to the alignment of the most recent
  layer, or a |tcb| alignment option to \ttx{boundinglayerscope}.  The origin is
  placed at the |north west|, |center| or |south west| of the bounding node, for
  \ttx t, \ttx c, or \ttx b alignment respectively.  The \ttx x vector extends
  horizontally to the east border of the bounding node, while \ttx y extends
  vertically to the opposite side (or top for \ttx c alignment).

  \begin{center}
  \begin{tikzpicture}[box/.style={draw, minimum width=6em, minimum height=6em},font={\tt\small}]
    \node[box] (t) {bounding layer};
    \node[below=2ex] at (t.south) {\ttx{t} alignment};
    \begin{scope}[shift=(t.north west), x=(t.north east), y=(t.south west)]
      \fill (0,0) circle (2pt);
      \draw[thick,->] (0,0) -- (1,0) node [midway,above] {x};
      \draw[thick,->] (0,0) -- (0,1) node [midway,left] {y};
      \node at (0,0) [above left,inner sep=0pt] {(0,0)};
      \node at (0,1) [below left,inner sep=0pt] {(0,1)};
      \node at (1,0) [above right,inner sep=0pt] {(1,0)};
    \end{scope}

    \node[box, right=8em, text height=4em] at (t.east) (c) {bounding layer};
    \node[below=2ex] at (c.south) {\ttx{c} alignment};
    \begin{scope}[shift=(c), x=(c.east), y=(c.north)]
      \fill (0,0) circle (2pt);
      \draw[thick,->] (0,0) -- (1,0) node [midway,below] {x};
      \draw[thick,->] (0,0) -- (0,1) node [midway,left] {y};
      \node at (0,0) [below left,inner sep=0pt] {(0,0)};
      \node at (0,1) [above left, inner sep=0pt] {(0,1)};
      \node at (1,0) [below right,inner sep=0pt] {(1,0)};
    \end{scope}


    \node[box, right=8em] at (c.east) (b) {bounding layer};
    \node[below=2ex] at (b.south) {\ttx{b} alignment};
    \begin{scope}[shift=(b.south west), x=(b.south east), y=(b.north west)]
      \fill (0,0) circle (2pt);
      \draw[thick,->] (0,0) -- (1,0) node [midway,below] {x};
      \draw[thick,->] (0,0) -- (0,1) node [midway,left] {y};
      \node at (0,0) [below left,inner sep=0pt] {(0,0)};
      \node at (0,1) [above left,inner sep=0pt] {(0,1)};
      \node at (1,0) [below right,inner sep=0pt] {(1,0)};
    \end{scope}
  \end{tikzpicture}
  \end{center}

  
\end{envwithcontents}
\begin{environment}{{layers<>}
    \oarg{parameter spec}\marg{code}\optsarg{default specification}}
  This is a synonym for |\begin{incrementallayers} ... \end{incrementallayers}|.
\end{environment}





\section{Incremental alignment environments}\label{sec:align}
\locsection{Alignment environments}

Standard \LaTeX\ alignment environments including \ttx{tabular} and the \ttx{align}
and \ttx{align*} environments from the \ttx{amsmath} package are not ordinarily
increment-aware.  The current package introduces a partial fix for this,
although their are remaining fragilities that may need to be worked around.  It
is possible to make an increment-aware version of any alignment environment
using \cmd\CreateIncrementalAlignmentEnvironment\ as described below.  A few such
environments are defined automatically when \beamincr\ is loaded and these are
described first, thus illustrating the behaviour once an increment-aware
environment has been created.

\subsection{Automatically defined incremental alignment environments}\label{sec:align:auto}

\vskip 2ex
\noindent
The following two environments are equivalent:
% \begin{environment}{{incrementalalign}\opt{\ttx{[<}\meta{spec1}\ttx{>\&<}\meta{spec2}\ttx{>\& ...]}}}
% \end{environment}
% \begin{environment}{{align<>}\opt{\ttx{[<}\meta{spec1}\ttx{>\&<}\meta{spec2}\ttx{>\& ...]}}}
% \end{environment}
\begin{environment}{{incrementalalign*}\opt{\ttx{[<\meta{spec1}>\&<\meta{spec2}>\&...]}}}
\end{environment}
\vskip -2ex
\begin{environment}{{align*<>}\opt{\ttx{[<\meta{spec1}>\&<\meta{spec2}>\&...]}}}
  Each pre-processes the input to \ttx{align*}, placing an |\action<>{}| command
  around each field, defined as the material appearing between successive |&|,
  |\\| or end environment tokens.  By default, the first field on a line is
  called with |\action<+->{}|, and up to 7 remaining ones with |\action<.->{}|.
  This has the effect of displaying a full line at a time, unless it has more
  than 8 fields.  The optional argument makes it possible to change this
  behaviour to \ttc{\action<\ometa{spec1}>}, \ttc{\action<\ometa{spec2}>},
  etc.\ with the sequence of specifications reset to \ttx{<\ometa{spec1}>} at
  the beginning of every line. If there are fewer specifications in the default
  than fields on a single line, then the sequence is repeated.  The default
  specification values can be changed by calling
  \cmd\setincrementalenvspec\ttx{\{align*\}\{<\meta{new default}>\}} or similar.

  The default specification for a single field can be overridden by placing a
  field-specific specification in \ttx{<>} at its start.  This means that a
  leading \ttx< in the field contents itself must be protected, e.g.\ by preceding
  it with |{}|.

  The use of \ttc\action\ means that \beamer\ will interpret both standard
  \ttx{action@\meta{increment}} actions and implicit ones such as \ttx!-prefixed
  increment resets, \ttx= label assignments or |~|\meta{range} default
  specification.
\example
\begin{verbatim}
  \begin{align*<>}[<+->&<.->] % increment after every two &s
    x\incrlabel{x} &= y  &  1 &{}< 2 \\
    </x/-> x^2 &= y^2    &  <!/x/-> e^{i\pi} &<+->= -1 \\
    \sum_n f(n) &<.-|alert@.> \to \int f(x) dx
  \end{align*<>}
\end{verbatim}
    
    The pre-processor is not able to distinguish between the |&| alignment
    characters that apply to the containing environment and any that appear
    within enclosed environments, such as \ttx{array}.  Thus, any such
    environments must be protected.  The simplest approach is just to add extra
    braces to group the enclose environment at a lower level.  Alternatively,
    the environment can be defined within a token register or a protected macro.
    It is still possible to use increments within the environments: these are
    processed sequentially with those in the containing |align| environment,
    respecting increment labels, resets etc.

    \example
\begin{verbatim}
  % using grouping
  \newtoks\mymatrix
  \begin{align<>}
    \incrlabel{mat}{\begin{pmatrix} 1 & 2 \\ \alt<+->{3}{2} & 4 \\ \end{pmatrix}}\resetincr[/mat/]
    & \text{is \only<+->{not }singular}
  \end{align<>}

  % using \protected
  \protected\def\mymatrix{\begin{pmatrix} 1 & 2 \\ \alt<+->{3}{2} & 4 \\ \end{pmatrix}}
  \begin{align<>}
    \incrlabel{mat}\mymatrix \resetincr[/mat/]& \text{is \only<+->{not }singular}
  \end{align<>}

  % using token registers
  \newtoks\mymatrix
  \mymatrix={\begin{pmatrix} 1 & 2 \\ \alt<+->{3}{2} & 4 \\ \end{pmatrix}}
  \begin{align<>}
    \incrlabel{mat}\the\mymatrix \resetincr[/mat/]& \text{is \only<+->{not }singular}
  \end{align<>}

\end{verbatim}
    It may be wise to put any \ttc\newtoks\ declaration outside the frame so as not
    to consume more of \TeX's resources than needed.  

    \ttc\intertext\ lines must be terminated with |\\|.  By default they will be
    grouped within the action call of the last field of the preceding line.
    This behaviour can be changed by inserting a |\\| between that field and the
    \ttc\intertext.  By default, both |\\|s will add extra vertical space (and an
    equation number in non-starred variants).  These can be avoided by using
    a form like |\nonumber\\[-3ex]| instead.

    The \ttx{amsmath} \ttc\tag\ command is processed in such a way that it
    cannot easily be made overlay aware.  Any \ttc\tag s will appear on any slides
    where the overall environment is uncovered, even if no fields have appeared.
    However, an alternative \cmd\eqtag\ is defined.  See \cref{sec:align:eqnum}.
    
\end{environment}
%
\begin{environment}{{incrementalgather*}\optsarg{default spec}}
\end{environment}
\vskip -2ex
\begin{environment}{{gather*<>}\optsarg{default spec}}
These incremental forms are also created when \beamincr\ is loaded, with similar
behaviour to the incremental \ttx{align*} environments described above.
Although these contain only one field per line, automatic access to \beamer\ and
\beamincr\ actions as these lines are processed can be useful.  By default, they
uncover equations a line at a time (using \ttx{<+->}).
\end{environment}


\begin{environment}{{incrementaltabular}\oarg{pos}\marg{cols}\opt{\tt[<\meta{spec1}>\&<\meta{spec2}>\&...]}}
\end{environment}
\vskip -2ex
\begin{environment}{{tabular<>}\oarg{pos}\marg{cols}\opt{\tt[<\meta{spec1}>\&<\meta{spec2}>\&...]}}
  These provide increment-aware versions of the standard \LaTeX\ \ttx{tabular}
  environment.  By default, the entire table is uncovered on the current
  increment (using \ttx{<.->}), but this behaviour can be altered by changing
  the default specification when called, or by using
  \cmd\setincrementalenvspec\ as described below.  It may also be desirable to
  uncover entries column-by-column.  This effect can be achieved using increment
  labels.  \example
\begin{verbatim}
\begin{tabular<>}{cccc}[</col1-/>&</col2-/>&</col3-/>&</col4-/>]
  <=(1)>/col1/\bf fruit & <=(2)>/col2/\bf colour  
      & <=(3)>/col3/\bf climate & <=(4)>/col4/\bf family \\[1ex]
  Apple & green & cool & pome \\
  Peach & yellow & warm & drupe \\
  Plum & purple & cool & drupe \\
  Orange & orange & hot & citrus \\
\end{tabular<>}  
\end{verbatim}
\end{environment}

\begin{environment}{{incrementaltabular*}\oarg{pos}\marg{width}\marg{cols}\opt{\tt[<\meta{spec1}>\&<\meta{spec2}>\& ...]}}
\end{environment}
\vskip -2ex
\begin{environment}{{tabular*<>}\oarg{pos}\marg{width}\marg{cols}\opt{\tt[<\meta{spec1}>\&<\meta{spec2}>\& ...]}}
  These forms add the \meta{width} argument of \LaTeX's \ttx{tabular*} environment.
\end{environment}

\subsection{Creating new incremental alignment environments}\label{sec:align:new}

\begin{command}{{\CreateIncrementalAlignmentEnvironment}\rlap{\marg{name}\oarg{Nopts}\marg{Nreqs}%
    \opt{\ttx{[<\meta{default spec}>]\oarg{base}}}}}
  {create \ttx{incremental\meta{name}} and \ttx{\meta{name}<>} variants of
    \meta{name} [or \ometa{base}] environment}
    
  Create an increment-aware version of an alignment environment.  Unless a
  different \meta{base} environment is specified in the final argument, the new
  environment is based on an existing one of the same \meta{name}.  This
  existing environment should process its contents in fields demarcated by |&|
  and/or |\\| tokens.  The arguments \meta{Nopts} and \meta{Nreqs} specify the
  numbers of optional and required arguments the base environment expects.  If
  \meta{Nopts} is omitted it is taken to be 0.  \meta{Nreqs} must be specified,
  but can be 0.  If the \meta{default specification} is omitted it is set to
  \ttx{<.->}, thus displaying the environment contents at the prevailing increment
  number in the frame.

  The new environment can be accessed using either of the names
  \ttx{incremental\meta{name}} or \ttx{\meta{name}<>}.
\end{command}

\subsection{Manipulating default behaviour}\label{sec:align:defaults}

\begin{command}{{\useincrementalenv}\marg{name}}%
  {make  subsequent uses of the \meta{name} call the incremental environment \ttx{\meta{name}<>}}
  Make all subsequent uses of the \meta{name} environment call the incremental
  version.  The incremental version must already have been created.
  \example
\begin{verbatim}
\useincrementalenv{align*}
\begin{align*}[<+->]
  % this is an incremental environment
\end{align*}
\end{verbatim}
  The specified \meta{name} must match the \emph{name} of the base environment
  (i.e., the first argument to \cmd\CreateIncrementalAlignmentEnvironment), whether
  or not this is the same as its base.
  %
\example
\begin{verbatim}
\CreateIncrementalAlignmentEnvironment{foo}{0}[<.->][bar]
\begin{foo}
  % error -- environment is accessible as incrementalfoo or foo<>
\end{foo}
\useincrementalenv{foo}
\begin{foo}
  % evokes the incremental version of bar
\end{foo}
\end{verbatim}
\end{command}

\begin{command}{{\usenonincrementalenv}\marg{name}}%
  {make subsequent uses of \meta{name} call non-incremental \meta{base} environment defined at creation}
  Make subsequent uses of the \meta{name} environment refer to the
  non-incremental version.  If the name and base specified at creation were the
  same, this restores the normal behaviour of the \meta{name} environment.  If a
  different base environment was specified at creation, this creates a new
  \meta{name} environment that is synonymous with the base.  \example
\begin{verbatim}
\CreateIncrementalAlignmentEnvironment{foo}{0}[<.->][bar]
\begin{foo}
  % error -- environment is accessible as incrementalfoo or foo<>
\end{foo}
\usenonincrementalenv{foo}
\begin{foo}
  % evokes the original version of bar
\end{foo}
\end{verbatim}
\end{command}


\begin{command}{{\setincrementalenvspec}\marg{name}\marg{default
      specification}}%
  {set the default specification for incremental \meta{name} environments }
  Set the default specification for incremental environments of type \meta{name}.
\end{command}


\subsection{Equation numbering}\label{sec:align:eqnum}

Unfortunately, the \ttx{amsmath} \ttc\tag\ command, used for equation numbering, is
processed in such a way that it cannot easily be made overlay aware.  Any
\ttc\tag{}s will appear on any slides where the overall environment is uncovered,
even if no fields have appeared.  This is also the case with automatic
numbering.  Thus if defined using
\begin{verbatim}
  \CreateIncrementalAlignmentEnvironment{gather}{0}[<+->]
\end{verbatim}
the \ttx{gather<>} environment will also generate all equation numbers whenever
the environment as a whole is uncovered, regardless of the status of the
relevant fields.  In principle, this behaviour could be partially addressed
using a technique discussed in the \beamer\ manual Howtos, but this requires
some additional hackery.

Instead, beamincr provides an increment-aware version of \ttc\tag\ and of
automatic equation numbering.
\begin{command}{\eqtag\sarg{overlay spec}\marg{tag}}%
  {place \meta{tag} on slides that match \meta{overlay spec}}
  Place \meta{tag} on slides that match \meta{overlay spec}.  
\end{command}
\begin{command}{\eqnum\sarg{overlay spec}}
  {place current equation number on slides that match \meta{overlay spec}, and increment}
%
  Place the current equation number (as \ttc\theequation) on slides that match
  \meta{overlay spec}, and then increment it.
\end{command}

The second form can be used as an action.
\begin{commandalt}[<eqnum@>]{{<eqnum@}\meta{range}\contcmd{>}}{}
  Place the current equation number (as \ttc\theequation) on slides in
  \meta{range}, and then increment it.
  \example
\begin{verbatim}
\begin{align*}[<+-|eqnum@+->&<.->]
  e^{\pi i} &= -1 \\
  \sqrt[3]{1} &= e^{2\pi i/3}
\end{align*}
\end{verbatim}
numbers equation as it is uncovered.  
\end{commandalt}

In principle, this method can be used to create automatic numbering forms of the
amsmath environments:
\begin{verbatim}
\CreateIncrementalAlignmentEnvironment{gather}{0}[<+-|eqnum@+->][gather*]
\begin{gather<>}
  % equations will be numbered, with numbers uncovered with the rest of the line
\end{gather<>}
\end{verbatim}
Such environments are not created automatically, as the user should be aware of
two traps.  First, if a default specification is given to |\begin{gather<>}|,
the environment will revert to unnumbered unless the appropriate \ttx{eqnum}
action or commands are provided.  Second, a call to
\cmd\usenonincrementalenv|{gather}| will make \ttx{gather} a synonym for
\ttx{gather*}.  At this point, there would be no easy way to restore \ttx{gather} to
its original behaviour.  You have been warned.


\section{Directing attention}\label{sec:attention}
\locsection{Directing attention}

\subsection{Alerts}

\begin{command}{\alerts\sarg{overlay spec}\marg{argument contents}}
  {activate \ttc{\alert*} commands in \meta{argument contents} on \meta{overlay spec}}
  %
  Activate any \cmd{\alert*} commands in \meta{argument contents} on the
  overlays indicated by \meta{overlay spec}.
\end{command}

\begin{commandalt}[<alerts@>]{{<alerts@}\meta{range}\contcmd>}{}
  This is the action equivalent of \cmd\alerts.
\end{commandalt}

\begin{command}{\alert*\marg{argument}}%
  {alert \meta{argument} when activated}
  %
  Executes \ttc\alert\marg{argument} if an enclosing \cmd\alerts\ command or
  action is active.  Otherwise \meta{argument} is displayed unalerted.
\end{command}



\subsection{Pointers}

\begin{command}{\point\osarg{overlay spec}\marg{contents}}%
  {insert pointer as appropriate, and activate \ttc{\point*} commands in \meta{range}}
  In normal text, insert a pointer before \meta{contents} on the specified
  slides.  If \meta{contents} includes any \cmd{\point*} commands, pointers are
  inserted at the locations of these commands at the same time.

  If called within a \TikZ\ picture, the \ttc\point\ command does not insert a
  pointer itself.  Instead, any pointer defined by the \ttx{pointer} option
  to any nodes in \meta{contents} is activated.  See the description of
  \ttx{pointer} below.
\end{command}

\begin{commandalt}[<point@>]{{<point@}\meta{range}\contcmd>}{}
  The action form of \cmd\point\ can be used in all contexts where an action
  specification is valid.  Its behaviour around normal text or \TikZ\ code is as
  above.  In \ttx{itemize} environments it replaces the default item label with
  the pointer\footnote{Although if the \ttx{itemize} is nested within an
  \ttx{enumerate}, it inherits the \ttx{enumerate} behaviour.}.  In
  \ttx{enumerate} environments it prepends the pointer to the default label.  In
  other list environments, or when the label is set explicitly as an optional
  argument to \ttc\item, it has no direct effect.  However any \cmd{\point*}
  commands in the item label or text are activated.
\end{commandalt}

\begin{commandalt}[<pointers@>]{{<pointers@}\meta{range}\contcmd>}{}
  This action activates \cmd{\point*} commands in the argument contents, but
  does not insert a pointer.
\end{commandalt}

\begin{command}{{\point*}\oarg{options}\opt{\marg{contents}}}
  {insert a pointer when activated (possibly using a \TikZ\ node around
    \ometa{contents})}
  %
  If the command is not followed by a |[| or |{| character, insert a pointer
      when an enclosing \cmd\point\ command or action is active.

  If followed by an argument in |[]| or |{}|, and if \TikZ\ is loaded, call
  \cmd\pointtonode\ as described below.  If \TikZ\ is \emph{not} loaded a normal
  pointer is inserted as in the no-argument form, any options are ignored, and
  the contents is copied to the output.
\end{command}

\begin{commandalt}[pointer (tikz option)]{{pointer}\opt{=}\oarg{pointer node options}\opt{\meta{angle}}}{}
  This is a \TikZ\ option that can be passed to a \ttx{node} to insert a
  pointer drawn towards the node whenever an enclosing \cmd\point\ command or
  action is active.  If an \meta{angle} is specified, the pointer is drawn
  towards the corresponding point on the node boundary; this can be specified as
  a numerical angle or a direction like \ttx{north}.  The default angle is
  \ttx{west} or \ttx{180}, so that the pointer points to the node from the
  left.  The pointer itself is drawn within a node: this behaviour is very
  similar to the regular \TikZ\ node \ttx{label} option, except that the
  pointer node is automatically sloped so as to point inwards.

  The current implementation does not work well with \ttx{coordinate}s.  The
  alternative \ttx{pointer coordinate} style creates an empty circular node
  of 0.1pt size, which is broadly equivalent.

  If \meta{pointer node options} are specified (generally requiring braces
  around the entire option value to protect \TikZ's option parsing from seeing
  the |[]|s) these are passed to the pointer node.  A few options may be
  particularly useful:
  \begin{description}
    \item[\tt pos=\meta{scale}] adjusts the placement of the pointer as a
      fraction of the distance from the target node centre to its boundary.  The
      default is 1.0.  This option is unlikely to be useful when the target is a
      \ttx{pointer coordinate}.
    \item[\tt pointer sep=\meta{dimen}] adds \meta{dimen} to the distance of the
      pointer from the target node.
    \item[\tt rotate=\meta{angle}] rotates the pointer relative to its initial
      angle.
  \end{description}
\end{commandalt}


\begin{command}{\pointtonode\oarg{{\tt pointer} options}\marg{contents}}
  {insert a pointer to a \TikZ\  node when activated}
  If \TikZ\ is loaded, this is shorthand for
\begin{verbatim}
  \tikz[baseline]\node[anchor=base,text height=1.5ex,inner sep=0pt,pointer={#1}]{#2};
\end{verbatim}
The spacing adjustments ensure that the contents in the node are printed in
alignment with the surrounding text, and that pointers to an empty node appear
at a similar height to those inserted by \cmd\point\ or \cmd{\point*}.  The
availability of \meta{{\tt pointer} options} provides flexibility in the pointer
placement.

If \TikZ\ is not loaded, this is the equivalent of \cmd{\point*}\marg{contents},
ignoring any options given.
\end{command}

\begin{command}{\usepointer\oarg{inactive glyph}\marg{pointer glyph}}
  {set the pointer glyph}
  %
  Use \meta{pointer glyph} for subsequent pointers in the current group.  If the
  optional argument is absent, then the pointer is replaced by a phantom of the
  same size when inactive (the size only matters if \cmd\useuncoverpointer\ is
  active).  If it is given, then inactive pointers are replaced by
  \meta{inactive glyph} (which may be empty).
  %
  \example
\begin{verbatim}
\usepointer{\raisebox{0.3ex}{\alert{$\blacktriangleright$}}} % the default
\usepointer{\raisebox{-0.4ex}{\alert{\HandRight}}} % requires \usepackage{bbding}
\end{verbatim}
Note that some adjustment of the vertical placement, as in these examples, may
be necessary to align the pointer appropriately with the text.

The effect of this command is local to the containing group. 

The pointer appearance should really be controlled through \beamer's template
mechanism, but that's a project for another day.
\end{command}

\begin{command}{\useoverprintpointer}
  {pointer glyphs take up no space and print on top of existing text}
  Print subsequent pointers (and any inactive glyphs) in the current group
  \emph{over} existing material, without reserving any space for them
  (internally, they set within a zero-width box). This is the default, and
  avoids the dilemma of either leaving blank spaces for inactive pointers, or
  having text rearrange when the pointer appears.

  The effect of this command is local to the containing group. 
\end{command}

\begin{command}{\useuncoverpointer}
  {reserve space for pointer glyphs}
  Set subsequent pointers and any inactive glyph in the current group as normal
  text, taking up space on the page.  If no inactive glyph has been specified,
  the effect is to leave a blank space when the pointer is inactive, much like
  the effect of the \ttc\uncover\ or \ttc\onslide\ commands.  If the inactive glyph is
  set to the empty string, there is no blank space, but surrounding text is
  rearranged to make room for the pointer when it becomes active.

  The effect of this command is local to the containing group. 
\end{command}

\section{Selectively repeating frames}\label{sec:again}
\locsection{Selectively repeating frames}

These functions control the (re)display of frames.

\begin{command}{\againframe\osarg{overlay spec}\ott{[\sarg{default spec}]}\oarg{options}\marg{frame label}}
  {repeat a labelled frame, allowing a new \meta{overlay spec} (now \beamincr-enabled) and other options}
  %
  This is a \beamer\ command to repeat a labelled frame, allowing the
  \meta{overlay spec} and other options to be modified.  It is modified in
  \beamincr\ so that the \meta{overlay spec} respects \beamincr\ increment
  labels, and so that any \cmd\framescanonly\ commands in the orginal frame
  contents are ignored (thus allowing the frame contents to be rendered).
\end{command}

\begin{command}{\handoutframe\oarg{modes}\osarg{overlay spec}\ott{[\sarg{default spec}]}\oarg{options}\marg{frame label}}
  {generate specified slides from labeleld frame in \meta{modes} (default \ttx{handout}) }
  %
  When compiled in one of \meta{modes} (defaults to \ttx{handout}, but can
  include more than one, e.g., \ttx{[beamer\textpipe handout]}), render the
  specified overlays from the named frame.  If \meta{overlay spec} is omitted,
  all the overlays are rendered.  No output is produced in modes other than
  \meta{modes}.

  The code works by switching temporarily to \ttx{beamer} mode as that seems
  to be the only way to produce more than one overlay per frame in
  \ttx{handout}, \ttx{trans} and \ttx{article} modes, although this
  means it may behave poorly with any mode-specific material within the frame.
  The idea is from
  \url{https://tex.stackexchange.com/questions/455444/beamer-overlays-and-handout-exclude-frames-from-handout/455459#455459}.
\end{command}

Unfortunately,  the natural code
\example
\begin{verbatim}
\begin{frame}<handout:0>[label=twolists]
  ...
\end{frame}
\handoutframe<1,/halfway/,/done/>{twolists}
\end{verbatim}
fails, because the \ttx{<handout:0>} spec stops the increment labels from being
defined.  If running a recent \LaTeX\ compiler (post 2021) the command
\ttc{\framescanonly<handout>} described below provides a workaround.  \example
\begin{verbatim}
\begin{frame}[label=twolists]
  \framescanonly<handout|trans>%
  ...
\end{frame}
\handoutframe[handout|trans]<1,/halfway/,/done/>{twolists}
\end{verbatim}


\begin{command}{\framescanonly\ttx{<\meta{modes}>}}
  {scan the current frame without producing output in \meta{modes}}
  %
  Scan the current frame without producing any output.  This is similar to a
  \ttx{<mode:0>} specification to \ttc{\begin\{frame\}}, but as the frame is still
  scanned it allows side effects such as increment label definitions.  The
  \cmd\framescanonly\ command should be placed inside the frame contents.  It is
  only available in recent versions of \LaTeX\ with hook support; a warning is
  printed in other cases.  If used in \ttx{beamer} mode the frame will be
  reprocessed for every overlay.  This behaviour can be avoided by also
  including a \ttx{<beamer:1>} or \ttx{<beamer:-1>} (but not \ttx{<beamer:0>}!)
  or equivalent specification to \ttc{\begin\{frame\}}. although it may be useful to
  fully expand advanced increment references when increments are reset (see
  \cref{sec:actions:advanced}).

  The command has no effect when the frame is recalled with \cmd\againframe\ or
  \cmd\handoutframe, allowing both commands to render the frame contents.  If it
  is necessary to suppress the output of (say) \cmd\againframe\ in certain
  modes, this can be achieved with the usual \ttx{<\meta{mode}:0>}
  specification.
  
  An example use appears above.
\end{command}

\begin{command}{\allowframescanonly\oarg{flag}}{allow frames to be only scanned}
  Disable (with \meta{flag} = 0) or enable (with \meta{flag} > 0 or omitted) the
  effect of \cmd\framescanonly.
\end{command}




\section{Internals}\label{sec:internals}

These sections discuss more background and some implementation details.   This
is only likely to be of interest to users who wish to extend the approach.


\subsection{Pauses, increments and the \ttx{beamerpauses} counter}\label{sec:internals:beamerpauses}
\locsection{{\sc Beamer} pause commands}

Both \ttc\pause\ and incremental overlay specifications access the same underlying
counter called \ttx{beamerpauses}, but they use them in different ways.

\begin{command}{\pause}{}
  increments \ttx{beamerpauses} and then sets subsequent material on the slide
  given by the incremented |\value{beamerpauses}|. 
\end{command}

\begin{command}{\onslide\ttx{<+->}}{}
  increments \ttx{beamerpauses} but then sets subsequent (or argument) material on
  the slide corresponding to the \emph{previous} value of \ttx{beamerpauses}.
\end{command}

\begin{command}{\onslide\ttx{<.->}}{}
  leaves \ttx{beamerpauses} alone, but sets subsequent (or argument) material on the
  slide given by |\value{beamerpauses}-1|, unless |\value{beamerpauses}=1| in
  which case it puts subsequent material on slide 1.
\end{command}
%
This conflict in interpretation of the \ttx{beamerpauses} counter can cause
unintuitive effects.  The incremental specfication model is far more flexible
and powerful, and so the commands of this package can all be interpreted in
terms of an \emph{increment number} which ordinarily equals
|max(\value{beamerpauses}-1,1)|.  In fact, internally they all use the
\ttx{beamerpauses} counter with this offset.  Thus, when commands like \cmd\resetincr\
set the increment value, they set \ttx{beamerpauses} to the increment + 1.  This
value then behaves sensibly with \ttx{<+>} etc.\ specifications, but not with
\ttc\pause.

An exception is when the current increment is set to 0, either explicitly or by
using an advanced (or otherwise undefined) increment reference.  In this case
\ttx{beamerpauses} is also set to 0, not 1.  This is because \beamincr\ references
use the 0 value to detect the undefined reference, and so suppress offsets and
ranges as described in \cref{sec:actions:advanced}.  However, subsequent uses of
\beamer's \ttx{<+>} specification will increment \ttx{beamerpauses}, potentially placing
text on earlier slides than intended.  This behaviour can be avoided (at the
expense of more typing) by using \ttx{<!/.(1)/>} instead.


\subsection{Overlay specification parsing routines}\label{sec:internals:parsing}
\locsection{Internal parsing commands}

The \beamincr\ overlay and action specification extensions work by injecting
various parsing routines into the core \beamer\ parser (called
|\beamer@masterdecode|), before calling the original function.  These parsers
are also available as user commands, and may be helpful for debugging (though
see also \cmd\beamincrdebug\ below).

\begin{command}{\parseincludedefaultspec \marg{overlay spec}}{todo}
  Replace any <|~|>fields in \meta{overlay spec} with the current default
  specification.
\end{command}
  
\begin{command}{\parseincrspec \marg{overlay spec}}{todo}
  Interpret any text enclosed in |/|s within \meta{overlay spec} as an increment
  specification, replacing each with the corresponding numerical values
  (including offset).  Also processes any open ranges internal to the label as
  described in \cref{sec:actions:advanced}.
\end{command}

\begin{command}{\parseresetspec \marg{overlay spec}}{todo}
\end{command}

\begin{command}{\parselabelspec \marg{overlay spec}}{todo}
\end{command}


\subsection{Interface with \beamer\ internals}\label{sec:internals:beamer}

Many \beamincr\ extensions work to pre-process material before passing it to
standard \beamer\ or other commands.  This section details the few cases were
it is necessary to interface with \beamer\ internals.

As described above, increment control is achieved by reading or setting the
\ttx{beamerpauses} counter.  The user-visible increment number corresponds to
|max(\value{beamerpauses}-1,1)|, so as to consistently match the slide numbers
on which increment-assigned material appears.  Many commands also read and
modify \beamer\ internal macros used as variables, notably
|\beamer@defaultospec| (the current default overlay specification) and
|\beamer@againname| (the label of the current frame, used to identify it in
calls to \cmd\againframe).  In particular, |\beamer@againname| is incorporated
into the internal name associated with \beamincr\ labels.

Extensions to the overlay and action specification syntax require modification
to the \beamer\ parsing routines, to inject the parsing routines described in
\cref{sec:internals:parsing}.  This is achieved using the following code.
\begin{verbatim}
\let\beamer@masterdecode@orig=\beamer@masterdecode
\def\beamer@masterdecode#1{%
  \edef\parsed@spec{\parseincludedefaultspec{#1}}%
  \edef\parsed@spec{\x@\parseincrspec\x@{\parsed@spec}}%
  \edef\parsed@spec{\x@\parseresetspec\x@{\parsed@spec}}%
  \edef\parsed@spec{\x@\parselabelspec\x@{\parsed@spec}}%
  \debug@message{masterdecode: <\unexpanded{#1}> -> <\parsed@spec>^^J}%
  \x@\beamer@masterdecode@orig\x@{\parsed@spec}%
}
\end{verbatim}
where \ttc\x@ is an internal abbreviation for \ttc\expandafter.

The command \cmd\againframe\ must be modified separately, both to interpret
increment references and to inhibit any \cmd\framescanonly\ in the contents.
\beamer\ uses a cascade of internal commands to read the various possible
optional arguments.  These are retained, with the change happening at the
inner-most command.
\begin{verbatim}
\let\beamer@@@againframe@orig=\beamer@@@againframe
\def\beamer@@@againframe<#1>[#2][#3]#4{%
  \edef\@scanstate{\@ifallowscanonlystate}%
  \allowframescanonly0%
  \beamer@@@againframe@orig<\parseincrspec{#1}>[#2][#3]{#4}%
  \x@\allowframescanonly\@scanstate%
}
\end{verbatim}
The \cmd\handoutframe\ command calls this redefined \cmd\againframe\ internal
after resetting the current mode to \ttx{beamer}.


\subsection{Debugging}\label{sec:internals:debugging}
\locsection{Debugging}

\begin{command}{\beamincrdebug \marg{flag}}{control generation of debugging information}
  Turn on (\meta{flag} > 0) or off (\meta{flag} = 0) debugging mode.  When on,
  compilation generates messages in the terminal output and log file describing
  the rewriting actions that \beamincr\ performs.
\end{command}


\newpage
\section{Reference}

\subsection{Increment, overlay and action specifications}


{% keep definitions local to table
\def\ooffset{\opt{\tt(\meta{offset})}}
\def\poffset{\opt{+\meta{offset}}}
\def\|{\kern3pt\vrule width0.4pt height1.9ex depth0.9ex\kern3pt}%$\Big|$}
\def\spec#1&{\multicolumn2l{\hskip2em \tt #1}&}

\setlength{\extrarowheight}{1ex}

\begin{tabularx}{\textwidth}{>{\tt}w{l}{8em} c X}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \meta{num} & integer &  explicit reference to slide number\\
  \hyperlink{label}{\meta{label}} & text & value assigned by |\incrlabel|\marg{label} or {\tt<=>}\\
  \cmdlink{<incrref>}{\meta{incrref}}  & \meta{label}\ooffset  & = \tt value\{\meta{label}\}\poffset\\
  \hfill\OR            & \tt .\ooffset  & = \tt \meta{current increment}\poffset\\
  \hfill\OR            & \tt !\ooffset  & = \tt \meta{last increment reset}\poffset\\
  \hyperlink{incrnum}{\meta{incrnum}} & \meta{num}\OR\tt /\meta{incrref}/ & increment number for |\resetincr|,
                                                                                        |\fromincr|, |\incrlabel| \\  
  \meta{incr} & \tt /\meta{incrref}/ & = \ttx{value\{\meta{incrref}\}} (including \offset)\\
  \hfill\OR       & \tt .\ooffset & = \tt\meta{current increment}\poffset\\
  \hfill\OR       & \tt +\ooffset & = \tt++\meta{current increment}\poffset\\
  \meta{slide} & \meta{num}\OR\meta{incr} & \\
  \meta{range} & \meta{slide}\OR\ometa{slide}\t-\ometa{slide} & (at least one \ometa{slide} must be present)\\
  \hfill\OR          & \tt /\meta{incrref}-/ & = {\tt0-0} if \meta{incrref}
                                                      evaluates to 0 or is undefined and\newline
                                                      |\allowundefinedincrlabels| is true\\ 
  \meta{mode} & \beamer\ mode & \tt beamer\OR trans\OR handout\OR presentation\OR article\OR all\\
  \meta{modes} & \tt \meta{mode}$_1$\textpipe\meta{mode}$_2$\textpipe \dots & \\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  
  <\meta{overlay spec}> & \multicolumn2l{} \\

  \spec <*> & active on all slides \\
  \spec <\meta{range}$_1$,\meta{range}$_2$,\dots> & active for slides within \meta{range}s \\

  \spec \cmdlink{tilde}{|<~>|} & copy default specification \\

    \spec <\meta{mode}:\meta{overlay spec}>
     & only apply \meta{overlay spec} in \meta{mode} \\
  \spec <\meta{overlay spec}$_1$\textpipe\meta{overlay spec}$_2$\textpipe \dots>
     & apply different \meta{overlay spec}s in different modes\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  <\meta{action spec}> \\

  \spec <\meta{overlay spec}> & \\

  \spec \cmdlink{<resetincr@>}{<resetincr@\meta{slide}>}
    &  set \meta{current increment} to \meta{slide}\\
  \spec \cmdlink{<!incrnum>}{<!\meta{incrnum}\opt{-\meta{incrnum}}>}
    & = \tt <resetincr@\meta{incrnum}\textpipe\meta{incrnum}\opt{-\meta{incrnum}}>\\

  \spec \cmdlink{<=>/label/}{<=\ooffset>\dots/\ooffset\meta{label}/ }a
    & set \meta{label} to increment in effect after \meta{action spec} \opt{+\offset s}\\

  \spec \cmdlink{<defaultspec@>}{<defaultspec@\meta{range}>}
    & set default spec within argument to \meta{range} evaluated in \meta{action spec}  \\
  \spec \cmdlink{tilde range}{<|~|\meta{range}>}
    &  = \tt <\meta{range}\textpipe defaultspec@\meta{range}> \\

  \spec \cmdlink{<eqnum@>}{<eqnum@\meta{range}>}
    & insert (and advance) |\theequation| tag for slides in \meta{range} \\

  \spec <alert@\meta{range}> & |\alert| argument for slides in \meta{range}\\
  \spec \cmdlink{<alerts@>}{<alerts@\meta{range}>}
    & activate \ttc{\alert*} commands  in argument in \meta{range}\\

  \spec \cmdlink{<point@>}{<point@\meta{range}>}
    & \ttc\point\ and activate \ttc{\point*} commands in \meta{range}\\
  \spec \cmdlink{<pointers@>}{<pointers@\meta{range}>}
    & activate |\point|\t* commands in argument in \meta{range}\\

  \spec <\meta{mode}:\meta{action spec}> & only apply \meta{action spec} in \meta{mode} \\
  \spec <\meta{action spec}$_1$\textpipe\meta{action spec}$_2$\textpipe \dots> & apply
  all \meta{action spec}s subject to any \meta{mode} restrictions \\

\end{tabularx}}

\newpage
\subsection{List of commands and environments}
\listofcommands
\end{document}


% for reference with \slideref{foo} (and/or </foo/>).
%
% The "increment number" is defined by the use of \pause and relative
% overlay commands like \onslide<+->.  In general, it corresponds to the slide
% on which text that followed the most recent <+> increment would
% appear.  For technical reasons this is one less than the value of the
% beamerpauses counter (unless that counter is 1).  This can cause confusion if
% \pause and <+> constructs are mixed.  

% the internal label name includes the frame label if one is given -- this helps
% to keep the references valid across frames



% \bibliographystyle{apalike} 
% \bibliography{journalsabbrv,neuro,learning}

\end{document}

% Local Variables:
% mode: latex
% eval: (set-fill-column 80)
% End:
